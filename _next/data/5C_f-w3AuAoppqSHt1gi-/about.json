{"pageProps":{"docs":[{"lang":"en_US","content":"# [Introduction](#introduction)\n\n---\n\nHat.sh is a free [opensource] web app that provides secure file encryption in the browser.\n\n<br>\n\n# [Features](#features)\n\n---\n\n### Security\n\n- [XChaCha20-Poly1305] - for symmetric encryption.\n- [Argon2id] - for password-based key derivation.\n- [X25519] - for key exchange.\n\nThe libsodium library is used for all cryptographic algorithms. [Technical details here](#technical-details).\n\n<br>\n\n### Privacy\n\n- The app runs locally in your browser.\n- No data is ever collected or sent to anyone.​\n\n<br>\n\n### Functionality\n\n- Secure encryption/decryption of files with passwords or keys.\n- Secure random password generation.\n- Asymmetric key pair generation.\n- Authenticated key exchange.\n- Password strength estimation.\n\n<br>\n\n# [Installation](#installation)\n\n---\nIt's easy to self host and deploy hat.sh, you can do that either with npm or docker\n\nIf you wish to self host the app please follow these instructions:\n\n<br>\n\n## With npm\n\nBefore installation make sure you are running [nodejs](https://nodejs.org/en/) and have [npm](https://www.npmjs.com/) installed\n\n<br >\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. install dependencies\n\n```bash\nnpm install\n```\n\n4. build app\n\n```bash\nnpm run build\n```\n\n5. start hat.sh\n\n```bash\nnpm run start\n```\n\nthe app should be running on port 3391.\n<br>\n\nif you wish to run the app in development enviroment run :\n\n<br>\n\n```bash\nnpm run dev\n```\n\n<br>\n\n## With docker\n\nYou can install the app with docker in multiple ways. You are free to choose which method you like.\n\n<br>\n\n- #### install from docker hub\n\n1. pull image from docker hub\n\n```bash\ndocker pull shdv/hat.sh:latest\n```\n\n2. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Build an image from source\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker\n\n```bash\ndocker build . -t shdv/hat.sh\n```\n\n4. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Using docker compose\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker compose\n\n```bash\ndocker compose build\n```\n\n4. run container\n\n```bash\ndocker compose up\n```\n\n<br>\n\nThe app should be running on port 3991.\n\nhat.sh is also available as a Docker image. You can find it on [Docker Hub].\n\n<br>\n\n\n# [Usage](#usage)\n\n---\n\n## File Encryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Enter a password or generate one.\n5. Download the encrypted file.\n\n> You should always use a strong password!\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Choose public key method.\n5. Enter or load recipient's public key and your private key.\n   if you don't have public and private keys you can generate a key pair.\n6. Download the encrypted file.\n7. Share your public key with the recipient so he will be able to decrypt the file.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n## File Decryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter the encryption password.\n5. Download the decrypted file.\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter or load sender's public key and your private key.\n5. Download the decrypted file.\n\n<br>\n\n# [Limitations](#limitations)\n\n---\n\n### File Signature\n\nFiles encrypted with hat.sh are identifiable by looking at the file signature that is used by the app to verify the content of a file, Such signatures are also known as magic numbers or Magic Bytes. These Bytes are authenticated and cannot be changed.\n\n### Safari and Mobile Browsers\n\nSafari and Mobile browsers are limited to a single file with maximum size of 1GB due to some issues related to service-workers. In addition, this limitation also applies when the app fails to register the service-worker (e.g FireFox Private Browsing).\n\n<br>\n\n# [Best Practices](#best-practices)\n\n---\n\n### Choosing Passwords\n\nThe majority of individuals struggle to create and remember passwords, resulting in weak passwords and password reuse. Password-based encryption is substantially less safe as a result of these improper practices. That's why it is recommended to use the built in password generator and use a password manager like [Bitwarden], where you are able to store the safe password.\n\n\nIf you want to choose a password that you are able to memorize then you should type a passphrase made of 8 words or more.\n\n<br>\n\n### Using public key encryption instead of a password\n\nIf you are encrypting a file that you are going to share it with someone else then you probably should encrypt it with the recipient public key and your private key.\n\n<br>\n\n### Sharing Encrypted Files\n\nIf you plan on sending someone an encrypted file, it is recommended to use your private key and their public key to encrypt the file.\n\nThe file can be shared in any safe file sharing app.\n\n<br>\n\n### Sharing the public key\n\nPublic keys are allowed to be shared, they can be sent as `.public` file or as text.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n### Storing the Public & Private keys\n\nMake sure to store your encryption keys in a safe place and make a backup to an external storage.\n\nStoring your private key in cloud storage is not recommended!\n\n<br>\n\n### Sharing Decryption Passwords\n\nSharing decryption password can be done using a safe end-to-end encrypted messaging app. It's recommended to use a _Disappearing Messages_ feature, and to delete the password after the recipient has decrypted the file.\n\n> Never choose the same password for different files.\n\n<br>\n\n# [FAQ](#faq)\n\n---\n\n### Does the app log or store any of my data?\n\nNo, hat.sh never stores any of your data. It only runs locally in your browser.\n\n<hr style=\"height: 1px\">\n\n### Is hat.sh free?\n\nYes, Hat.sh is free and always will be. However, please consider [donating](https://github.com/sh-dv/hat.sh#donations) to support the project.\n\n<hr style=\"height: 1px\">\n\n### Which file types are supported? Is there a file size limit?\n\nHat.sh accepts all file types. There's no file size limit, meaning files of any size can be encrypted.\n\nSafari browser and mobile/smartphones browsers are limited to 1GB.\n\n<hr style=\"height: 1px\">\n\n### I forgot my password, can I still decrypt my files?\n\nNo, we don't know your password. Always make sure to store your passwords in a password manager.\n\n<hr style=\"height: 1px\">\n\n### Why am I seeing a notice that says \"You have limited experience (single file, 1GB)\"?\n\nIt means that your browser doesn't support the server-worker fetch api. Hence, you are limited to small size files. see [Limitations](#limitations) for more info.\n\n<hr style=\"height: 1px\" id=\"why-need-private-key\">\n\n### Is it safe to share my public key?\n\nYes. Public keys are allowed to be shared, they can be sent as `.public` file or as text.\n\nBut make sure to never share your private key with anyone!\n\n<hr style=\"height: 1px\">\n\n### Why the app asks for my private key in the public key encryption mode?\n\nHat.sh uses authenticated encryption. The sender must provide their private key, a new shared key will be computed from both keys to encrypt the file. Recipient has to provide their private key when decrypting also. this way can verify that the encrypted file was not tampered with, and was sent from the real sender.\n\n<hr style=\"height: 1px\">\n\n### I have lost my private key, is it possible to recover it?\n\nNope. lost private keys cannot be recovered.\n\nAlso, if you feel that your private key has been compromised (e.g accidentally shared / computer hacked) then you must decrypt all files that were encrypted with that key, generate a new keypair and re-encrypt the files.\n\n<hr style=\"height: 1px\">\n\n### How do I generate a keypair (Public & Private)?\n\nYou can generate keys by visit the [key generate page](https://hat.sh/generate-keys), make sure to [store the keys safely](#best-practices).\n\n<hr style=\"height: 1px\">\n\n### Does the app measure password strength?\n\nWe use [zxcvbn](https://github.com/dropbox/zxcvbn) JS implementation to check the entropy of the password input, this entropy will be converted to score that will be displayed on screen.\n\n<hr style=\"height: 1px\">\n\n### Does the app connect to the internet?\n\nOnce you visit the site and the page loads, it runs only offline.\n\n<hr style=\"height: 1px\">\n\n### How can I contribute?\n\nHat.sh is an open-source application. You can help make it better by making commits on GitHub. The project is maintained in my free time. [Donations](https://github.com/sh-dv/hat.sh#donations) of any size are appreciated.\n\n<hr style=\"height: 1px\">\n\n### How do I report bugs?\n\nPlease report bugs via [Github] by opening an issue labeled with \"bug\".\n\n<hr style=\"height: 1px\">\n\n### How do I report a security vulnerability?\n\nIf you identify a valid security issue, please write an email to hatsh-security@pm.me\n\nThere is no bounty available at the moment, but your github account will be credited in the acknowledgements section in the app documentation.\n\n<hr style=\"height: 1px\">\n\n### Why should I use hat.sh?\n\n1. The app uses fast modern secure cryptographic algorithms.\n2. It's super fast and easy to use.\n3. It runs in the browser, no need to setup or install anything.\n4. It's free opensource software and can be easily self hosted.\n\n<hr style=\"height: 1px\">\n\n### When should I not use hat.sh?\n\n1. If you want to encrypt a disk (e.g [VeraCrypt]).\n2. If you want to frequently access encrypted files (e.g [Cryptomator]).\n3. If you want to encrypt and sign files in the same tool. (e.g [Kryptor]).\n4. If you prefer a command line tool (e.g [Kryptor]).\n5. If you want something that adheres to industry standards, use [GPG].\n\n<br>\n\n# [Technical Details](#technical-details)\n\n---\n\n### Password hashing and Key derivation\n\nPassword hashing functions derive a secret key of any size from a password and a salt.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet salt = sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);\nlet key = sodium.crypto_pwhash(\n  sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES,\n  password,\n  salt,\n  sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_ALG_ARGON2ID13\n);\n```\n\n</div>\n\nThe `crypto_pwhash()` function derives an 256 bits long key from a password and a salt salt whose fixed length is 128 bits, which should be unpredictable.\n\n`randombytes_buf()` is the easiest way to fill the 128 bits of the salt.\n\n<br>\n\n`OPSLIMIT` represents a maximum amount of computations to perform.\n\n`MEMLIMIT` is the maximum amount of RAM that the function will use, in bytes.\n\n<br>\n\n`crypto_pwhash_OPSLIMIT_INTERACTIVE` and `crypto_pwhash_MEMLIMIT_INTERACTIVE` provide base line for these two parameters. This currently requires 64 MiB of dedicated RAM. which is suitable for in-browser operations.\n<br>\n`crypto_pwhash_ALG_ARGON2ID13` using the Argon2id algorithm version 1.3.\n\n<br>\n\n### File Encryption (stream)\n\nIn order to use the app to encrypt a file, the user has to provide a valid file and a password. this password gets hashed and a secure key is derived from it with Argon2id to encrypt the file.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet res = sodium.crypto_secretstream_xchacha20poly1305_init_push(key);\nheader = res.header;\nstate = res.state;\n\nlet tag = last\n  ? sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL\n  : sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;\n\nlet encryptedChunk = sodium.crypto_secretstream_xchacha20poly1305_push(\n  state,\n  new Uint8Array(chunk),\n  null,\n  tag\n);\n\nstream.enqueue(signature, salt, header, encryptedChunk);\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_push` function creates an encrypted stream where it initializes a `state` using the key and an internal, automatically generated initialization vector. It then stores the stream header into `header` that has a size of 192 bits.\n\nThis is the first function to call in order to create an encrypted stream. The key will not be required any more for subsequent operations.\n\n<br>\n\nAn encrypted stream starts with a short header, whose size is 192 bits. That header must be sent/stored before the sequence of encrypted messages, as it is required to decrypt the stream. The header content doesn't have to be secret because decryption with a different header would fail.\n\nA tag is attached to each message accoring to the value of `last`, which indicates if that is the last chunk of the file or not. That tag can be any of:\n\n1. `crypto_secretstream_xchacha20poly1305_TAG_MESSAGE`: This doesn't add any information about the nature of the message.\n2. `crypto_secretstream_xchacha20poly1305_TAG_FINAL`: This indicates that the message marks the end of the stream, and erases the secret key used to encrypt the previous sequence.\n\nThe `crypto_secretstream_xchacha20poly1305_push()` function encrypts the file `chunk` using the `state` and the `tag`, without any additional information (`null`).\n<br>\n\nthe XChaCha20 stream cipher Poly1305 MAC authentication are used for encryption.\n\n`stream.enqueue()` function adds the hat.sh signature(magic bytes), salt and header followed by the encrypted chunks.\n\n### File Decryption (stream)\n\n<div class=\"codeBox\">\n\n```javascript\nlet state = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n\nlet result = sodium.crypto_secretstream_xchacha20poly1305_pull(\n  state,\n  new Uint8Array(chunk)\n);\n\nif (result) {\n  let decryptedChunk = result.message;\n  stream.enqueue(decryptedChunk);\n\n  if (!last) {\n    // continue decryption\n  }\n}\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_pull()` function initializes a state given a secret `key` and a `header`. The key is derived from the password provided during the decryption, and the header sliced from the file. The key will not be required any more for subsequent operations.\n\n<br>\n\nThe `crypto_secretstream_xchacha20poly1305_pull()` function verifies that the `chunk` contains a valid ciphertext and authentication tag for the given `state`.\n\nThis function will stay in a loop, until a message with the `crypto_secretstream_xchacha20poly1305_TAG_FINAL` tag is found.\n\nIf the decryption key is incorrect the function returns an error.\n\nIf the ciphertext or the authentication tag appear to be invalid it returns an error.\n\n<br>\n\n### Random password generation\n\n<div class=\"codeBox\">\n\n```javascript\nlet password = sodium.to_base64(\n  sodium.randombytes_buf(16),\n  sodium.base64_variants.URLSAFE_NO_PADDING\n);\nreturn password;\n```\n\n</div>\n\nThe `randombytes_buf()` function fills 128 bits starting at buf with an unpredictable sequence of bytes.\n\nThe `to_base64()` function encodes buf as a Base64 string without padding.\n\n<br>\n\n### Keys generation and exchange\n\n<div class=\"codeBox\">\n\n```javascript\nconst keyPair = sodium.crypto_kx_keypair();\nlet keys = {\n  publicKey: sodium.to_base64(keyPair.publicKey),\n  privateKey: sodium.to_base64(keyPair.privateKey),\n};\nreturn keys;\n```\n</div>\n\nThe `crypto_kx_keypair()` function randomly generates a secret key and a corresponding public key. The public key is put into publicKey and the secret key into privateKey. both of 256 bits.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet key = sodium.crypto_kx_client_session_keys(\n  sodium.crypto_scalarmult_base(privateKey),\n  privateKey,\n  publicKey\n);\n```\n</div>\n\nUsing the key exchange API, two parties can securely compute a set of shared keys using their peer's public key and their own secret key.\n\nThe `crypto_kx_client_session_keys()` function computes a pair of 256 bits long shared keys using the recipient's public key, the sender's private key.\n\nThe `crypto_scalarmult_base()` function used to compute the sender's public key from their private key.\n\n<br>\n\n### XChaCha20-Poly1305\n\nXChaCha20 is a variant of ChaCha20 with an extended nonce, allowing random nonces to be safe.\n\nXChaCha20 doesn't require any lookup tables and avoids the possibility of timing attacks.\n\nInternally, XChaCha20 works like a block cipher used in counter mode. It uses the HChaCha20 hash function to derive a subkey and a subnonce from the original key and extended nonce, and a dedicated 64-bit block counter to avoid incrementing the nonce after each block.\n\n<br>\n\n### V2 vs V1\n\n- switching to xchacha20poly1305 for symmetric stream encryption and Argon2id for password-based key derivation. instead of AES-256-GCM and PBKDF2.\n- using the libsodium library for all cryptography instead of the WebCryptoApi.\n- in this version, the app doesn't read the whole file in memory. instead, it's sliced into 64MB chunks that are processed one by one.\n- since we are not using any server-side processing, the app registers a fake download URL (/file) that is going to be handled by the service-worker fetch api.\n- if all validations are passed, a new stream is initialized. then, file chunks are transferred from the main app to the\n  service-worker file via messages.\n- each chunk is encrypted/decrypted on it's own and added to the stream.\n- after each chunk is written on disk it is going to be immediately garbage collected by the browser, this leads to never having more than a few chunks in the memory at the same time.\n\n<br>\n\n[//]: # \"links\"\n[xchacha20-poly1305]: https://libsodium.gitbook.io/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction\n[argon2id]: https://github.com/p-h-c/phc-winner-argon2\n[x25519]: https://cr.yp.to/ecdh.html\n[opensource]: https://github.com/sh-dv/hat.sh\n[bitwarden]: https://bitwarden.com/\n[extending the salsa20 nonce paper]: https://cr.yp.to/snuffle/xsalsa-20081128.pdf\n[soon]: https://tools.ietf.org/html/draft-irtf-cfrg-xchacha\n[github]: https://github.com/sh-dv/hat.sh\n[veracrypt]: https://veracrypt.fr\n[cryptomator]: https://cryptomator.org\n[kryptor]: https://github.com/samuel-lucas6/Kryptor\n[gpg]: https://gnupg.org\n[docker hub]: https://hub.docker.com/r/shdv/hat.sh\n"},{"lang":"fr_FR","content":"# [Introduction](#introduction)\n\n---\n\nHat.sh is a free [opensource] web app that provides secure file encryption in the browser.\n\n<br>\n\n# [Features](#features)\n\n---\n\n### Security\n\n- [XChaCha20-Poly1305] - for symmetric encryption.\n- [Argon2id] - for password-based key derivation.\n- [X25519] - for key exchange.\n\nThe libsodium library is used for all cryptographic algorithms. [Technical details here](#technical-details).\n\n<br>\n\n### Privacy\n\n- The app runs locally in your browser.\n- No data is ever collected or sent to anyone.​\n\n<br>\n\n### Functionality\n\n- Secure encryption/decryption of files with passwords or keys.\n- Secure random password generation.\n- Asymmetric key pair generation.\n- Authenticated key exchange.\n- Password strength estimation.\n\n<br>\n\n# [Installation](#installation)\n\n---\nIt's easy to self host and deploy hat.sh, you can do that either with npm or docker\n\nIf you wish to self host the app please follow these instructions:\n\n<br>\n\n## With npm\n\nBefore installation make sure you are running [nodejs](https://nodejs.org/en/) and have [npm](https://www.npmjs.com/) installed\n\n<br >\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. install dependencies\n\n```bash\nnpm install\n```\n\n4. build app\n\n```bash\nnpm run build\n```\n\n5. start hat.sh\n\n```bash\nnpm run start\n```\n\nthe app should be running on port 3391.\n<br>\n\nif you wish to run the app in development enviroment run :\n\n<br>\n\n```bash\nnpm run dev\n```\n\n<br>\n\n## With docker\n\nYou can install the app with docker in multiple ways. You are free to choose which method you like.\n\n<br>\n\n- #### install from docker hub\n\n1. pull image from docker hub\n\n```bash\ndocker pull shdv/hat.sh:latest\n```\n\n2. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Build an image from source\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker\n\n```bash\ndocker build . -t shdv/hat.sh\n```\n\n4. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Using docker compose\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker compose\n\n```bash\ndocker compose build\n```\n\n4. run container\n\n```bash\ndocker compose up\n```\n\n<br>\n\nThe app should be running on port 3991.\n\nhat.sh is also available as a Docker image. You can find it on [Docker Hub].\n\n<br>\n\n\n# [Usage](#usage)\n\n---\n\n## File Encryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Enter a password or generate one.\n5. Download the encrypted file.\n\n> You should always use a strong password!\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Choose public key method.\n5. Enter or load recipient's public key and your private key.\n   if you don't have public and private keys you can generate a key pair.\n6. Download the encrypted file.\n7. Share your public key with the recipient so he will be able to decrypt the file.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n## File Decryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter the encryption password.\n5. Download the decrypted file.\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter or load sender's public key and your private key.\n5. Download the decrypted file.\n\n<br>\n\n# [Limitations](#limitations)\n\n---\n\n### File Signature\n\nFiles encrypted with hat.sh are identifiable by looking at the file signature that is used by the app to verify the content of a file, Such signatures are also known as magic numbers or Magic Bytes. These Bytes are authenticated and cannot be changed.\n\n### Safari and Mobile Browsers\n\nSafari and Mobile browsers are limited to a single file with maximum size of 1GB due to some issues related to service-workers. In addition, this limitation also applies when the app fails to register the service-worker (e.g FireFox Private Browsing).\n\n<br>\n\n# [Best Practices](#best-practices)\n\n---\n\n### Choosing Passwords\n\nThe majority of individuals struggle to create and remember passwords, resulting in weak passwords and password reuse. Password-based encryption is substantially less safe as a result of these improper practices. That's why it is recommended to use the built in password generator and use a password manager like [Bitwarden], where you are able to store the safe password.\n\n\nIf you want to choose a password that you are able to memorize then you should type a passphrase made of 8 words or more.\n\n<br>\n\n### Using public key encryption instead of a password\n\nIf you are encrypting a file that you are going to share it with someone else then you probably should encrypt it with the recipient public key and your private key.\n\n<br>\n\n### Sharing Encrypted Files\n\nIf you plan on sending someone an encrypted file, it is recommended to use your private key and their public key to encrypt the file.\n\nThe file can be shared in any safe file sharing app.\n\n<br>\n\n### Sharing the public key\n\nPublic keys are allowed to be shared, they can be sent as `.public` file or as text.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n### Storing the Public & Private keys\n\nMake sure to store your encryption keys in a safe place and make a backup to an external storage.\n\nStoring your private key in cloud storage is not recommended!\n\n<br>\n\n### Sharing Decryption Passwords\n\nSharing decryption password can be done using a safe end-to-end encrypted messaging app. It's recommended to use a _Disappearing Messages_ feature, and to delete the password after the recipient has decrypted the file.\n\n> Never choose the same password for different files.\n\n<br>\n\n# [FAQ](#faq)\n\n---\n\n### Does the app log or store any of my data?\n\nNo, hat.sh never stores any of your data. It only runs locally in your browser.\n\n<hr style=\"height: 1px\">\n\n### Is hat.sh free?\n\nYes, Hat.sh is free and always will be. However, please consider [donating](https://github.com/sh-dv/hat.sh#donations) to support the project.\n\n<hr style=\"height: 1px\">\n\n### Which file types are supported? Is there a file size limit?\n\nHat.sh accepts all file types. There's no file size limit, meaning files of any size can be encrypted.\n\nSafari browser and mobile/smartphones browsers are limited to 1GB.\n\n<hr style=\"height: 1px\">\n\n### I forgot my password, can I still decrypt my files?\n\nNo, we don't know your password. Always make sure to store your passwords in a password manager.\n\n<hr style=\"height: 1px\">\n\n### Why am I seeing a notice that says \"You have limited experience (single file, 1GB)\"?\n\nIt means that your browser doesn't support the server-worker fetch api. Hence, you are limited to small size files. see [Limitations](#limitations) for more info.\n\n<hr style=\"height: 1px\" id=\"why-need-private-key\">\n\n### Is it safe to share my public key?\n\nYes. Public keys are allowed to be shared, they can be sent as `.public` file or as text.\n\nBut make sure to never share your private key with anyone!\n\n<hr style=\"height: 1px\">\n\n### Why the app asks for my private key in the public key encryption mode?\n\nHat.sh uses authenticated encryption. The sender must provide their private key, a new shared key will be computed from both keys to encrypt the file. Recipient has to provide their private key when decrypting also. this way can verify that the encrypted file was not tampered with, and was sent from the real sender.\n\n<hr style=\"height: 1px\">\n\n### I have lost my private key, is it possible to recover it?\n\nNope. lost private keys cannot be recovered.\n\nAlso, if you feel that your private key has been compromised (e.g accidentally shared / computer hacked) then you must decrypt all files that were encrypted with that key, generate a new keypair and re-encrypt the files.\n\n<hr style=\"height: 1px\">\n\n### How do I generate a keypair (Public & Private)?\n\nYou can generate keys by visit the [key generate page](https://hat.sh/generate-keys), make sure to [store the keys safely](#best-practices).\n\n<hr style=\"height: 1px\">\n\n### Does the app measure password strength?\n\nWe use [zxcvbn](https://github.com/dropbox/zxcvbn) JS implementation to check the entropy of the password input, this entropy will be converted to score that will be displayed on screen.\n\n<hr style=\"height: 1px\">\n\n### Does the app connect to the internet?\n\nOnce you visit the site and the page loads, it runs only offline.\n\n<hr style=\"height: 1px\">\n\n### How can I contribute?\n\nHat.sh is an open-source application. You can help make it better by making commits on GitHub. The project is maintained in my free time. [Donations](https://github.com/sh-dv/hat.sh#donations) of any size are appreciated.\n\n<hr style=\"height: 1px\">\n\n### How do I report bugs?\n\nPlease report bugs via [Github] by opening an issue labeled with \"bug\".\n\n<hr style=\"height: 1px\">\n\n### How do I report a security vulnerability?\n\nIf you identify a valid security issue, please write an email to hatsh-security@pm.me\n\nThere is no bounty available at the moment, but your github account will be credited in the acknowledgements section in the app documentation.\n\n<hr style=\"height: 1px\">\n\n### Why should I use hat.sh?\n\n1. The app uses fast modern secure cryptographic algorithms.\n2. It's super fast and easy to use.\n3. It runs in the browser, no need to setup or install anything.\n4. It's free opensource software and can be easily self hosted.\n\n<hr style=\"height: 1px\">\n\n### When should I not use hat.sh?\n\n1. If you want to encrypt a disk (e.g [VeraCrypt]).\n2. If you want to frequently access encrypted files (e.g [Cryptomator]).\n3. If you want to encrypt and sign files in the same tool. (e.g [Kryptor]).\n4. If you prefer a command line tool (e.g [Kryptor]).\n5. If you want something that adheres to industry standards, use [GPG].\n\n<br>\n\n# [Technical Details](#technical-details)\n\n---\n\n### Password hashing and Key derivation\n\nPassword hashing functions derive a secret key of any size from a password and a salt.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet salt = sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);\nlet key = sodium.crypto_pwhash(\n  sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES,\n  password,\n  salt,\n  sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_ALG_ARGON2ID13\n);\n```\n\n</div>\n\nThe `crypto_pwhash()` function derives an 256 bits long key from a password and a salt salt whose fixed length is 128 bits, which should be unpredictable.\n\n`randombytes_buf()` is the easiest way to fill the 128 bits of the salt.\n\n<br>\n\n`OPSLIMIT` represents a maximum amount of computations to perform.\n\n`MEMLIMIT` is the maximum amount of RAM that the function will use, in bytes.\n\n<br>\n\n`crypto_pwhash_OPSLIMIT_INTERACTIVE` and `crypto_pwhash_MEMLIMIT_INTERACTIVE` provide base line for these two parameters. This currently requires 64 MiB of dedicated RAM. which is suitable for in-browser operations.\n<br>\n`crypto_pwhash_ALG_ARGON2ID13` using the Argon2id algorithm version 1.3.\n\n<br>\n\n### File Encryption (stream)\n\nIn order to use the app to encrypt a file, the user has to provide a valid file and a password. this password gets hashed and a secure key is derived from it with Argon2id to encrypt the file.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet res = sodium.crypto_secretstream_xchacha20poly1305_init_push(key);\nheader = res.header;\nstate = res.state;\n\nlet tag = last\n  ? sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL\n  : sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;\n\nlet encryptedChunk = sodium.crypto_secretstream_xchacha20poly1305_push(\n  state,\n  new Uint8Array(chunk),\n  null,\n  tag\n);\n\nstream.enqueue(signature, salt, header, encryptedChunk);\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_push` function creates an encrypted stream where it initializes a `state` using the key and an internal, automatically generated initialization vector. It then stores the stream header into `header` that has a size of 192 bits.\n\nThis is the first function to call in order to create an encrypted stream. The key will not be required any more for subsequent operations.\n\n<br>\n\nAn encrypted stream starts with a short header, whose size is 192 bits. That header must be sent/stored before the sequence of encrypted messages, as it is required to decrypt the stream. The header content doesn't have to be secret because decryption with a different header would fail.\n\nA tag is attached to each message accoring to the value of `last`, which indicates if that is the last chunk of the file or not. That tag can be any of:\n\n1. `crypto_secretstream_xchacha20poly1305_TAG_MESSAGE`: This doesn't add any information about the nature of the message.\n2. `crypto_secretstream_xchacha20poly1305_TAG_FINAL`: This indicates that the message marks the end of the stream, and erases the secret key used to encrypt the previous sequence.\n\nThe `crypto_secretstream_xchacha20poly1305_push()` function encrypts the file `chunk` using the `state` and the `tag`, without any additional information (`null`).\n<br>\n\nthe XChaCha20 stream cipher Poly1305 MAC authentication are used for encryption.\n\n`stream.enqueue()` function adds the hat.sh signature(magic bytes), salt and header followed by the encrypted chunks.\n\n### File Decryption (stream)\n\n<div class=\"codeBox\">\n\n```javascript\nlet state = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n\nlet result = sodium.crypto_secretstream_xchacha20poly1305_pull(\n  state,\n  new Uint8Array(chunk)\n);\n\nif (result) {\n  let decryptedChunk = result.message;\n  stream.enqueue(decryptedChunk);\n\n  if (!last) {\n    // continue decryption\n  }\n}\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_pull()` function initializes a state given a secret `key` and a `header`. The key is derived from the password provided during the decryption, and the header sliced from the file. The key will not be required any more for subsequent operations.\n\n<br>\n\nThe `crypto_secretstream_xchacha20poly1305_pull()` function verifies that the `chunk` contains a valid ciphertext and authentication tag for the given `state`.\n\nThis function will stay in a loop, until a message with the `crypto_secretstream_xchacha20poly1305_TAG_FINAL` tag is found.\n\nIf the decryption key is incorrect the function returns an error.\n\nIf the ciphertext or the authentication tag appear to be invalid it returns an error.\n\n<br>\n\n### Random password generation\n\n<div class=\"codeBox\">\n\n```javascript\nlet password = sodium.to_base64(\n  sodium.randombytes_buf(16),\n  sodium.base64_variants.URLSAFE_NO_PADDING\n);\nreturn password;\n```\n\n</div>\n\nThe `randombytes_buf()` function fills 128 bits starting at buf with an unpredictable sequence of bytes.\n\nThe `to_base64()` function encodes buf as a Base64 string without padding.\n\n<br>\n\n### Keys generation and exchange\n\n<div class=\"codeBox\">\n\n```javascript\nconst keyPair = sodium.crypto_kx_keypair();\nlet keys = {\n  publicKey: sodium.to_base64(keyPair.publicKey),\n  privateKey: sodium.to_base64(keyPair.privateKey),\n};\nreturn keys;\n```\n</div>\n\nThe `crypto_kx_keypair()` function randomly generates a secret key and a corresponding public key. The public key is put into publicKey and the secret key into privateKey. both of 256 bits.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet key = sodium.crypto_kx_client_session_keys(\n  sodium.crypto_scalarmult_base(privateKey),\n  privateKey,\n  publicKey\n);\n```\n</div>\n\nUsing the key exchange API, two parties can securely compute a set of shared keys using their peer's public key and their own secret key.\n\nThe `crypto_kx_client_session_keys()` function computes a pair of 256 bits long shared keys using the recipient's public key, the sender's private key.\n\nThe `crypto_scalarmult_base()` function used to compute the sender's public key from their private key.\n\n<br>\n\n### XChaCha20-Poly1305\n\nXChaCha20 is a variant of ChaCha20 with an extended nonce, allowing random nonces to be safe.\n\nXChaCha20 doesn't require any lookup tables and avoids the possibility of timing attacks.\n\nInternally, XChaCha20 works like a block cipher used in counter mode. It uses the HChaCha20 hash function to derive a subkey and a subnonce from the original key and extended nonce, and a dedicated 64-bit block counter to avoid incrementing the nonce after each block.\n\n<br>\n\n### V2 vs V1\n\n- switching to xchacha20poly1305 for symmetric stream encryption and Argon2id for password-based key derivation. instead of AES-256-GCM and PBKDF2.\n- using the libsodium library for all cryptography instead of the WebCryptoApi.\n- in this version, the app doesn't read the whole file in memory. instead, it's sliced into 64MB chunks that are processed one by one.\n- since we are not using any server-side processing, the app registers a fake download URL (/file) that is going to be handled by the service-worker fetch api.\n- if all validations are passed, a new stream is initialized. then, file chunks are transferred from the main app to the\n  service-worker file via messages.\n- each chunk is encrypted/decrypted on it's own and added to the stream.\n- after each chunk is written on disk it is going to be immediately garbage collected by the browser, this leads to never having more than a few chunks in the memory at the same time.\n\n<br>\n\n[//]: # \"links\"\n[xchacha20-poly1305]: https://libsodium.gitbook.io/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction\n[argon2id]: https://github.com/p-h-c/phc-winner-argon2\n[x25519]: https://cr.yp.to/ecdh.html\n[opensource]: https://github.com/sh-dv/hat.sh\n[bitwarden]: https://bitwarden.com/\n[extending the salsa20 nonce paper]: https://cr.yp.to/snuffle/xsalsa-20081128.pdf\n[soon]: https://tools.ietf.org/html/draft-irtf-cfrg-xchacha\n[github]: https://github.com/sh-dv/hat.sh\n[veracrypt]: https://veracrypt.fr\n[cryptomator]: https://cryptomator.org\n[kryptor]: https://github.com/samuel-lucas6/Kryptor\n[gpg]: https://gnupg.org\n[docker hub]: https://hub.docker.com/r/shdv/hat.sh\n"},{"lang":"de_DE","content":"# [Introduction](#introduction)\n\n---\n\nHat.sh is a free [opensource] web app that provides secure file encryption in the browser.\n\n<br>\n\n# [Features](#features)\n\n---\n\n### Security\n\n- [XChaCha20-Poly1305] - for symmetric encryption.\n- [Argon2id] - for password-based key derivation.\n- [X25519] - for key exchange.\n\nThe libsodium library is used for all cryptographic algorithms. [Technical details here](#technical-details).\n\n<br>\n\n### Privacy\n\n- The app runs locally in your browser.\n- No data is ever collected or sent to anyone.​\n\n<br>\n\n### Functionality\n\n- Secure encryption/decryption of files with passwords or keys.\n- Secure random password generation.\n- Asymmetric key pair generation.\n- Authenticated key exchange.\n- Password strength estimation.\n\n<br>\n\n# [Installation](#installation)\n\n---\nIt's easy to self host and deploy hat.sh, you can do that either with npm or docker\n\nIf you wish to self host the app please follow these instructions:\n\n<br>\n\n## With npm\n\nBefore installation make sure you are running [nodejs](https://nodejs.org/en/) and have [npm](https://www.npmjs.com/) installed\n\n<br >\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. install dependencies\n\n```bash\nnpm install\n```\n\n4. build app\n\n```bash\nnpm run build\n```\n\n5. start hat.sh\n\n```bash\nnpm run start\n```\n\nthe app should be running on port 3391.\n<br>\n\nif you wish to run the app in development enviroment run :\n\n<br>\n\n```bash\nnpm run dev\n```\n\n<br>\n\n## With docker\n\nYou can install the app with docker in multiple ways. You are free to choose which method you like.\n\n<br>\n\n- #### install from docker hub\n\n1. pull image from docker hub\n\n```bash\ndocker pull shdv/hat.sh:latest\n```\n\n2. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Build an image from source\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker\n\n```bash\ndocker build . -t shdv/hat.sh\n```\n\n4. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Using docker compose\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker compose\n\n```bash\ndocker compose build\n```\n\n4. run container\n\n```bash\ndocker compose up\n```\n\n<br>\n\nThe app should be running on port 3991.\n\nhat.sh is also available as a Docker image. You can find it on [Docker Hub].\n\n<br>\n\n\n# [Usage](#usage)\n\n---\n\n## File Encryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Enter a password or generate one.\n5. Download the encrypted file.\n\n> You should always use a strong password!\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Choose public key method.\n5. Enter or load recipient's public key and your private key.\n   if you don't have public and private keys you can generate a key pair.\n6. Download the encrypted file.\n7. Share your public key with the recipient so he will be able to decrypt the file.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n## File Decryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter the encryption password.\n5. Download the decrypted file.\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter or load sender's public key and your private key.\n5. Download the decrypted file.\n\n<br>\n\n# [Limitations](#limitations)\n\n---\n\n### File Signature\n\nFiles encrypted with hat.sh are identifiable by looking at the file signature that is used by the app to verify the content of a file, Such signatures are also known as magic numbers or Magic Bytes. These Bytes are authenticated and cannot be changed.\n\n### Safari and Mobile Browsers\n\nSafari and Mobile browsers are limited to a single file with maximum size of 1GB due to some issues related to service-workers. In addition, this limitation also applies when the app fails to register the service-worker (e.g FireFox Private Browsing).\n\n<br>\n\n# [Best Practices](#best-practices)\n\n---\n\n### Choosing Passwords\n\nThe majority of individuals struggle to create and remember passwords, resulting in weak passwords and password reuse. Password-based encryption is substantially less safe as a result of these improper practices. That's why it is recommended to use the built in password generator and use a password manager like [Bitwarden], where you are able to store the safe password.\n\n\nIf you want to choose a password that you are able to memorize then you should type a passphrase made of 8 words or more.\n\n<br>\n\n### Using public key encryption instead of a password\n\nIf you are encrypting a file that you are going to share it with someone else then you probably should encrypt it with the recipient public key and your private key.\n\n<br>\n\n### Sharing Encrypted Files\n\nIf you plan on sending someone an encrypted file, it is recommended to use your private key and their public key to encrypt the file.\n\nThe file can be shared in any safe file sharing app.\n\n<br>\n\n### Sharing the public key\n\nPublic keys are allowed to be shared, they can be sent as `.public` file or as text.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n### Storing the Public & Private keys\n\nMake sure to store your encryption keys in a safe place and make a backup to an external storage.\n\nStoring your private key in cloud storage is not recommended!\n\n<br>\n\n### Sharing Decryption Passwords\n\nSharing decryption password can be done using a safe end-to-end encrypted messaging app. It's recommended to use a _Disappearing Messages_ feature, and to delete the password after the recipient has decrypted the file.\n\n> Never choose the same password for different files.\n\n<br>\n\n# [FAQ](#faq)\n\n---\n\n### Does the app log or store any of my data?\n\nNo, hat.sh never stores any of your data. It only runs locally in your browser.\n\n<hr style=\"height: 1px\">\n\n### Is hat.sh free?\n\nYes, Hat.sh is free and always will be. However, please consider [donating](https://github.com/sh-dv/hat.sh#donations) to support the project.\n\n<hr style=\"height: 1px\">\n\n### Which file types are supported? Is there a file size limit?\n\nHat.sh accepts all file types. There's no file size limit, meaning files of any size can be encrypted.\n\nSafari browser and mobile/smartphones browsers are limited to 1GB.\n\n<hr style=\"height: 1px\">\n\n### I forgot my password, can I still decrypt my files?\n\nNo, we don't know your password. Always make sure to store your passwords in a password manager.\n\n<hr style=\"height: 1px\">\n\n### Why am I seeing a notice that says \"You have limited experience (single file, 1GB)\"?\n\nIt means that your browser doesn't support the server-worker fetch api. Hence, you are limited to small size files. see [Limitations](#limitations) for more info.\n\n<hr style=\"height: 1px\" id=\"why-need-private-key\">\n\n### Is it safe to share my public key?\n\nYes. Public keys are allowed to be shared, they can be sent as `.public` file or as text.\n\nBut make sure to never share your private key with anyone!\n\n<hr style=\"height: 1px\">\n\n### Why the app asks for my private key in the public key encryption mode?\n\nHat.sh uses authenticated encryption. The sender must provide their private key, a new shared key will be computed from both keys to encrypt the file. Recipient has to provide their private key when decrypting also. this way can verify that the encrypted file was not tampered with, and was sent from the real sender.\n\n<hr style=\"height: 1px\">\n\n### I have lost my private key, is it possible to recover it?\n\nNope. lost private keys cannot be recovered.\n\nAlso, if you feel that your private key has been compromised (e.g accidentally shared / computer hacked) then you must decrypt all files that were encrypted with that key, generate a new keypair and re-encrypt the files.\n\n<hr style=\"height: 1px\">\n\n### How do I generate a keypair (Public & Private)?\n\nYou can generate keys by visit the [key generate page](https://hat.sh/generate-keys), make sure to [store the keys safely](#best-practices).\n\n<hr style=\"height: 1px\">\n\n### Does the app measure password strength?\n\nWe use [zxcvbn](https://github.com/dropbox/zxcvbn) JS implementation to check the entropy of the password input, this entropy will be converted to score that will be displayed on screen.\n\n<hr style=\"height: 1px\">\n\n### Does the app connect to the internet?\n\nOnce you visit the site and the page loads, it runs only offline.\n\n<hr style=\"height: 1px\">\n\n### How can I contribute?\n\nHat.sh is an open-source application. You can help make it better by making commits on GitHub. The project is maintained in my free time. [Donations](https://github.com/sh-dv/hat.sh#donations) of any size are appreciated.\n\n<hr style=\"height: 1px\">\n\n### How do I report bugs?\n\nPlease report bugs via [Github] by opening an issue labeled with \"bug\".\n\n<hr style=\"height: 1px\">\n\n### How do I report a security vulnerability?\n\nIf you identify a valid security issue, please write an email to hatsh-security@pm.me\n\nThere is no bounty available at the moment, but your github account will be credited in the acknowledgements section in the app documentation.\n\n<hr style=\"height: 1px\">\n\n### Why should I use hat.sh?\n\n1. The app uses fast modern secure cryptographic algorithms.\n2. It's super fast and easy to use.\n3. It runs in the browser, no need to setup or install anything.\n4. It's free opensource software and can be easily self hosted.\n\n<hr style=\"height: 1px\">\n\n### When should I not use hat.sh?\n\n1. If you want to encrypt a disk (e.g [VeraCrypt]).\n2. If you want to frequently access encrypted files (e.g [Cryptomator]).\n3. If you want to encrypt and sign files in the same tool. (e.g [Kryptor]).\n4. If you prefer a command line tool (e.g [Kryptor]).\n5. If you want something that adheres to industry standards, use [GPG].\n\n<br>\n\n# [Technical Details](#technical-details)\n\n---\n\n### Password hashing and Key derivation\n\nPassword hashing functions derive a secret key of any size from a password and a salt.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet salt = sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);\nlet key = sodium.crypto_pwhash(\n  sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES,\n  password,\n  salt,\n  sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_ALG_ARGON2ID13\n);\n```\n\n</div>\n\nThe `crypto_pwhash()` function derives an 256 bits long key from a password and a salt salt whose fixed length is 128 bits, which should be unpredictable.\n\n`randombytes_buf()` is the easiest way to fill the 128 bits of the salt.\n\n<br>\n\n`OPSLIMIT` represents a maximum amount of computations to perform.\n\n`MEMLIMIT` is the maximum amount of RAM that the function will use, in bytes.\n\n<br>\n\n`crypto_pwhash_OPSLIMIT_INTERACTIVE` and `crypto_pwhash_MEMLIMIT_INTERACTIVE` provide base line for these two parameters. This currently requires 64 MiB of dedicated RAM. which is suitable for in-browser operations.\n<br>\n`crypto_pwhash_ALG_ARGON2ID13` using the Argon2id algorithm version 1.3.\n\n<br>\n\n### File Encryption (stream)\n\nIn order to use the app to encrypt a file, the user has to provide a valid file and a password. this password gets hashed and a secure key is derived from it with Argon2id to encrypt the file.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet res = sodium.crypto_secretstream_xchacha20poly1305_init_push(key);\nheader = res.header;\nstate = res.state;\n\nlet tag = last\n  ? sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL\n  : sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;\n\nlet encryptedChunk = sodium.crypto_secretstream_xchacha20poly1305_push(\n  state,\n  new Uint8Array(chunk),\n  null,\n  tag\n);\n\nstream.enqueue(signature, salt, header, encryptedChunk);\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_push` function creates an encrypted stream where it initializes a `state` using the key and an internal, automatically generated initialization vector. It then stores the stream header into `header` that has a size of 192 bits.\n\nThis is the first function to call in order to create an encrypted stream. The key will not be required any more for subsequent operations.\n\n<br>\n\nAn encrypted stream starts with a short header, whose size is 192 bits. That header must be sent/stored before the sequence of encrypted messages, as it is required to decrypt the stream. The header content doesn't have to be secret because decryption with a different header would fail.\n\nA tag is attached to each message accoring to the value of `last`, which indicates if that is the last chunk of the file or not. That tag can be any of:\n\n1. `crypto_secretstream_xchacha20poly1305_TAG_MESSAGE`: This doesn't add any information about the nature of the message.\n2. `crypto_secretstream_xchacha20poly1305_TAG_FINAL`: This indicates that the message marks the end of the stream, and erases the secret key used to encrypt the previous sequence.\n\nThe `crypto_secretstream_xchacha20poly1305_push()` function encrypts the file `chunk` using the `state` and the `tag`, without any additional information (`null`).\n<br>\n\nthe XChaCha20 stream cipher Poly1305 MAC authentication are used for encryption.\n\n`stream.enqueue()` function adds the hat.sh signature(magic bytes), salt and header followed by the encrypted chunks.\n\n### File Decryption (stream)\n\n<div class=\"codeBox\">\n\n```javascript\nlet state = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n\nlet result = sodium.crypto_secretstream_xchacha20poly1305_pull(\n  state,\n  new Uint8Array(chunk)\n);\n\nif (result) {\n  let decryptedChunk = result.message;\n  stream.enqueue(decryptedChunk);\n\n  if (!last) {\n    // continue decryption\n  }\n}\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_pull()` function initializes a state given a secret `key` and a `header`. The key is derived from the password provided during the decryption, and the header sliced from the file. The key will not be required any more for subsequent operations.\n\n<br>\n\nThe `crypto_secretstream_xchacha20poly1305_pull()` function verifies that the `chunk` contains a valid ciphertext and authentication tag for the given `state`.\n\nThis function will stay in a loop, until a message with the `crypto_secretstream_xchacha20poly1305_TAG_FINAL` tag is found.\n\nIf the decryption key is incorrect the function returns an error.\n\nIf the ciphertext or the authentication tag appear to be invalid it returns an error.\n\n<br>\n\n### Random password generation\n\n<div class=\"codeBox\">\n\n```javascript\nlet password = sodium.to_base64(\n  sodium.randombytes_buf(16),\n  sodium.base64_variants.URLSAFE_NO_PADDING\n);\nreturn password;\n```\n\n</div>\n\nThe `randombytes_buf()` function fills 128 bits starting at buf with an unpredictable sequence of bytes.\n\nThe `to_base64()` function encodes buf as a Base64 string without padding.\n\n<br>\n\n### Keys generation and exchange\n\n<div class=\"codeBox\">\n\n```javascript\nconst keyPair = sodium.crypto_kx_keypair();\nlet keys = {\n  publicKey: sodium.to_base64(keyPair.publicKey),\n  privateKey: sodium.to_base64(keyPair.privateKey),\n};\nreturn keys;\n```\n</div>\n\nThe `crypto_kx_keypair()` function randomly generates a secret key and a corresponding public key. The public key is put into publicKey and the secret key into privateKey. both of 256 bits.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet key = sodium.crypto_kx_client_session_keys(\n  sodium.crypto_scalarmult_base(privateKey),\n  privateKey,\n  publicKey\n);\n```\n</div>\n\nUsing the key exchange API, two parties can securely compute a set of shared keys using their peer's public key and their own secret key.\n\nThe `crypto_kx_client_session_keys()` function computes a pair of 256 bits long shared keys using the recipient's public key, the sender's private key.\n\nThe `crypto_scalarmult_base()` function used to compute the sender's public key from their private key.\n\n<br>\n\n### XChaCha20-Poly1305\n\nXChaCha20 is a variant of ChaCha20 with an extended nonce, allowing random nonces to be safe.\n\nXChaCha20 doesn't require any lookup tables and avoids the possibility of timing attacks.\n\nInternally, XChaCha20 works like a block cipher used in counter mode. It uses the HChaCha20 hash function to derive a subkey and a subnonce from the original key and extended nonce, and a dedicated 64-bit block counter to avoid incrementing the nonce after each block.\n\n<br>\n\n### V2 vs V1\n\n- switching to xchacha20poly1305 for symmetric stream encryption and Argon2id for password-based key derivation. instead of AES-256-GCM and PBKDF2.\n- using the libsodium library for all cryptography instead of the WebCryptoApi.\n- in this version, the app doesn't read the whole file in memory. instead, it's sliced into 64MB chunks that are processed one by one.\n- since we are not using any server-side processing, the app registers a fake download URL (/file) that is going to be handled by the service-worker fetch api.\n- if all validations are passed, a new stream is initialized. then, file chunks are transferred from the main app to the\n  service-worker file via messages.\n- each chunk is encrypted/decrypted on it's own and added to the stream.\n- after each chunk is written on disk it is going to be immediately garbage collected by the browser, this leads to never having more than a few chunks in the memory at the same time.\n\n<br>\n\n[//]: # \"links\"\n[xchacha20-poly1305]: https://libsodium.gitbook.io/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction\n[argon2id]: https://github.com/p-h-c/phc-winner-argon2\n[x25519]: https://cr.yp.to/ecdh.html\n[opensource]: https://github.com/sh-dv/hat.sh\n[bitwarden]: https://bitwarden.com/\n[extending the salsa20 nonce paper]: https://cr.yp.to/snuffle/xsalsa-20081128.pdf\n[soon]: https://tools.ietf.org/html/draft-irtf-cfrg-xchacha\n[github]: https://github.com/sh-dv/hat.sh\n[veracrypt]: https://veracrypt.fr\n[cryptomator]: https://cryptomator.org\n[kryptor]: https://github.com/samuel-lucas6/Kryptor\n[gpg]: https://gnupg.org\n[docker hub]: https://hub.docker.com/r/shdv/hat.sh\n"},{"lang":"zh_CN","content":"# [Introduction](#introduction)\n\n---\n\nHat.sh is a free [opensource] web app that provides secure file encryption in the browser.\n\n<br>\n\n# [Features](#features)\n\n---\n\n### Security\n\n- [XChaCha20-Poly1305] - for symmetric encryption.\n- [Argon2id] - for password-based key derivation.\n- [X25519] - for key exchange.\n\nThe libsodium library is used for all cryptographic algorithms. [Technical details here](#technical-details).\n\n<br>\n\n### Privacy\n\n- The app runs locally in your browser.\n- No data is ever collected or sent to anyone.​\n\n<br>\n\n### Functionality\n\n- Secure encryption/decryption of files with passwords or keys.\n- Secure random password generation.\n- Asymmetric key pair generation.\n- Authenticated key exchange.\n- Password strength estimation.\n\n<br>\n\n# [Installation](#installation)\n\n---\nIt's easy to self host and deploy hat.sh, you can do that either with npm or docker\n\nIf you wish to self host the app please follow these instructions:\n\n<br>\n\n## With npm\n\nBefore installation make sure you are running [nodejs](https://nodejs.org/en/) and have [npm](https://www.npmjs.com/) installed\n\n<br >\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. install dependencies\n\n```bash\nnpm install\n```\n\n4. build app\n\n```bash\nnpm run build\n```\n\n5. start hat.sh\n\n```bash\nnpm run start\n```\n\nthe app should be running on port 3391.\n<br>\n\nif you wish to run the app in development enviroment run :\n\n<br>\n\n```bash\nnpm run dev\n```\n\n<br>\n\n## With docker\n\nYou can install the app with docker in multiple ways. You are free to choose which method you like.\n\n<br>\n\n- #### install from docker hub\n\n1. pull image from docker hub\n\n```bash\ndocker pull shdv/hat.sh:latest\n```\n\n2. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Build an image from source\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker\n\n```bash\ndocker build . -t shdv/hat.sh\n```\n\n4. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Using docker compose\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker compose\n\n```bash\ndocker compose build\n```\n\n4. run container\n\n```bash\ndocker compose up\n```\n\n<br>\n\nThe app should be running on port 3991.\n\nhat.sh is also available as a Docker image. You can find it on [Docker Hub].\n\n<br>\n\n\n# [Usage](#usage)\n\n---\n\n## File Encryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Enter a password or generate one.\n5. Download the encrypted file.\n\n> You should always use a strong password!\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Choose public key method.\n5. Enter or load recipient's public key and your private key.\n   if you don't have public and private keys you can generate a key pair.\n6. Download the encrypted file.\n7. Share your public key with the recipient so he will be able to decrypt the file.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n## File Decryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter the encryption password.\n5. Download the decrypted file.\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter or load sender's public key and your private key.\n5. Download the decrypted file.\n\n<br>\n\n# [Limitations](#limitations)\n\n---\n\n### File Signature\n\nFiles encrypted with hat.sh are identifiable by looking at the file signature that is used by the app to verify the content of a file, Such signatures are also known as magic numbers or Magic Bytes. These Bytes are authenticated and cannot be changed.\n\n### Safari and Mobile Browsers\n\nSafari and Mobile browsers are limited to a single file with maximum size of 1GB due to some issues related to service-workers. In addition, this limitation also applies when the app fails to register the service-worker (e.g FireFox Private Browsing).\n\n<br>\n\n# [Best Practices](#best-practices)\n\n---\n\n### Choosing Passwords\n\nThe majority of individuals struggle to create and remember passwords, resulting in weak passwords and password reuse. Password-based encryption is substantially less safe as a result of these improper practices. That's why it is recommended to use the built in password generator and use a password manager like [Bitwarden], where you are able to store the safe password.\n\n\nIf you want to choose a password that you are able to memorize then you should type a passphrase made of 8 words or more.\n\n<br>\n\n### Using public key encryption instead of a password\n\nIf you are encrypting a file that you are going to share it with someone else then you probably should encrypt it with the recipient public key and your private key.\n\n<br>\n\n### Sharing Encrypted Files\n\nIf you plan on sending someone an encrypted file, it is recommended to use your private key and their public key to encrypt the file.\n\nThe file can be shared in any safe file sharing app.\n\n<br>\n\n### Sharing the public key\n\nPublic keys are allowed to be shared, they can be sent as `.public` file or as text.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n### Storing the Public & Private keys\n\nMake sure to store your encryption keys in a safe place and make a backup to an external storage.\n\nStoring your private key in cloud storage is not recommended!\n\n<br>\n\n### Sharing Decryption Passwords\n\nSharing decryption password can be done using a safe end-to-end encrypted messaging app. It's recommended to use a _Disappearing Messages_ feature, and to delete the password after the recipient has decrypted the file.\n\n> Never choose the same password for different files.\n\n<br>\n\n# [FAQ](#faq)\n\n---\n\n### Does the app log or store any of my data?\n\nNo, hat.sh never stores any of your data. It only runs locally in your browser.\n\n<hr style=\"height: 1px\">\n\n### Is hat.sh free?\n\nYes, Hat.sh is free and always will be. However, please consider [donating](https://github.com/sh-dv/hat.sh#donations) to support the project.\n\n<hr style=\"height: 1px\">\n\n### Which file types are supported? Is there a file size limit?\n\nHat.sh accepts all file types. There's no file size limit, meaning files of any size can be encrypted.\n\nSafari browser and mobile/smartphones browsers are limited to 1GB.\n\n<hr style=\"height: 1px\">\n\n### I forgot my password, can I still decrypt my files?\n\nNo, we don't know your password. Always make sure to store your passwords in a password manager.\n\n<hr style=\"height: 1px\">\n\n### Why am I seeing a notice that says \"You have limited experience (single file, 1GB)\"?\n\nIt means that your browser doesn't support the server-worker fetch api. Hence, you are limited to small size files. see [Limitations](#limitations) for more info.\n\n<hr style=\"height: 1px\" id=\"why-need-private-key\">\n\n### Is it safe to share my public key?\n\nYes. Public keys are allowed to be shared, they can be sent as `.public` file or as text.\n\nBut make sure to never share your private key with anyone!\n\n<hr style=\"height: 1px\">\n\n### Why the app asks for my private key in the public key encryption mode?\n\nHat.sh uses authenticated encryption. The sender must provide their private key, a new shared key will be computed from both keys to encrypt the file. Recipient has to provide their private key when decrypting also. this way can verify that the encrypted file was not tampered with, and was sent from the real sender.\n\n<hr style=\"height: 1px\">\n\n### I have lost my private key, is it possible to recover it?\n\nNope. lost private keys cannot be recovered.\n\nAlso, if you feel that your private key has been compromised (e.g accidentally shared / computer hacked) then you must decrypt all files that were encrypted with that key, generate a new keypair and re-encrypt the files.\n\n<hr style=\"height: 1px\">\n\n### How do I generate a keypair (Public & Private)?\n\nYou can generate keys by visit the [key generate page](https://hat.sh/generate-keys), make sure to [store the keys safely](#best-practices).\n\n<hr style=\"height: 1px\">\n\n### Does the app measure password strength?\n\nWe use [zxcvbn](https://github.com/dropbox/zxcvbn) JS implementation to check the entropy of the password input, this entropy will be converted to score that will be displayed on screen.\n\n<hr style=\"height: 1px\">\n\n### Does the app connect to the internet?\n\nOnce you visit the site and the page loads, it runs only offline.\n\n<hr style=\"height: 1px\">\n\n### How can I contribute?\n\nHat.sh is an open-source application. You can help make it better by making commits on GitHub. The project is maintained in my free time. [Donations](https://github.com/sh-dv/hat.sh#donations) of any size are appreciated.\n\n<hr style=\"height: 1px\">\n\n### How do I report bugs?\n\nPlease report bugs via [Github] by opening an issue labeled with \"bug\".\n\n<hr style=\"height: 1px\">\n\n### How do I report a security vulnerability?\n\nIf you identify a valid security issue, please write an email to hatsh-security@pm.me\n\nThere is no bounty available at the moment, but your github account will be credited in the acknowledgements section in the app documentation.\n\n<hr style=\"height: 1px\">\n\n### Why should I use hat.sh?\n\n1. The app uses fast modern secure cryptographic algorithms.\n2. It's super fast and easy to use.\n3. It runs in the browser, no need to setup or install anything.\n4. It's free opensource software and can be easily self hosted.\n\n<hr style=\"height: 1px\">\n\n### When should I not use hat.sh?\n\n1. If you want to encrypt a disk (e.g [VeraCrypt]).\n2. If you want to frequently access encrypted files (e.g [Cryptomator]).\n3. If you want to encrypt and sign files in the same tool. (e.g [Kryptor]).\n4. If you prefer a command line tool (e.g [Kryptor]).\n5. If you want something that adheres to industry standards, use [GPG].\n\n<br>\n\n# [Technical Details](#technical-details)\n\n---\n\n### Password hashing and Key derivation\n\nPassword hashing functions derive a secret key of any size from a password and a salt.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet salt = sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);\nlet key = sodium.crypto_pwhash(\n  sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES,\n  password,\n  salt,\n  sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_ALG_ARGON2ID13\n);\n```\n\n</div>\n\nThe `crypto_pwhash()` function derives an 256 bits long key from a password and a salt salt whose fixed length is 128 bits, which should be unpredictable.\n\n`randombytes_buf()` is the easiest way to fill the 128 bits of the salt.\n\n<br>\n\n`OPSLIMIT` represents a maximum amount of computations to perform.\n\n`MEMLIMIT` is the maximum amount of RAM that the function will use, in bytes.\n\n<br>\n\n`crypto_pwhash_OPSLIMIT_INTERACTIVE` and `crypto_pwhash_MEMLIMIT_INTERACTIVE` provide base line for these two parameters. This currently requires 64 MiB of dedicated RAM. which is suitable for in-browser operations.\n<br>\n`crypto_pwhash_ALG_ARGON2ID13` using the Argon2id algorithm version 1.3.\n\n<br>\n\n### File Encryption (stream)\n\nIn order to use the app to encrypt a file, the user has to provide a valid file and a password. this password gets hashed and a secure key is derived from it with Argon2id to encrypt the file.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet res = sodium.crypto_secretstream_xchacha20poly1305_init_push(key);\nheader = res.header;\nstate = res.state;\n\nlet tag = last\n  ? sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL\n  : sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;\n\nlet encryptedChunk = sodium.crypto_secretstream_xchacha20poly1305_push(\n  state,\n  new Uint8Array(chunk),\n  null,\n  tag\n);\n\nstream.enqueue(signature, salt, header, encryptedChunk);\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_push` function creates an encrypted stream where it initializes a `state` using the key and an internal, automatically generated initialization vector. It then stores the stream header into `header` that has a size of 192 bits.\n\nThis is the first function to call in order to create an encrypted stream. The key will not be required any more for subsequent operations.\n\n<br>\n\nAn encrypted stream starts with a short header, whose size is 192 bits. That header must be sent/stored before the sequence of encrypted messages, as it is required to decrypt the stream. The header content doesn't have to be secret because decryption with a different header would fail.\n\nA tag is attached to each message accoring to the value of `last`, which indicates if that is the last chunk of the file or not. That tag can be any of:\n\n1. `crypto_secretstream_xchacha20poly1305_TAG_MESSAGE`: This doesn't add any information about the nature of the message.\n2. `crypto_secretstream_xchacha20poly1305_TAG_FINAL`: This indicates that the message marks the end of the stream, and erases the secret key used to encrypt the previous sequence.\n\nThe `crypto_secretstream_xchacha20poly1305_push()` function encrypts the file `chunk` using the `state` and the `tag`, without any additional information (`null`).\n<br>\n\nthe XChaCha20 stream cipher Poly1305 MAC authentication are used for encryption.\n\n`stream.enqueue()` function adds the hat.sh signature(magic bytes), salt and header followed by the encrypted chunks.\n\n### File Decryption (stream)\n\n<div class=\"codeBox\">\n\n```javascript\nlet state = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n\nlet result = sodium.crypto_secretstream_xchacha20poly1305_pull(\n  state,\n  new Uint8Array(chunk)\n);\n\nif (result) {\n  let decryptedChunk = result.message;\n  stream.enqueue(decryptedChunk);\n\n  if (!last) {\n    // continue decryption\n  }\n}\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_pull()` function initializes a state given a secret `key` and a `header`. The key is derived from the password provided during the decryption, and the header sliced from the file. The key will not be required any more for subsequent operations.\n\n<br>\n\nThe `crypto_secretstream_xchacha20poly1305_pull()` function verifies that the `chunk` contains a valid ciphertext and authentication tag for the given `state`.\n\nThis function will stay in a loop, until a message with the `crypto_secretstream_xchacha20poly1305_TAG_FINAL` tag is found.\n\nIf the decryption key is incorrect the function returns an error.\n\nIf the ciphertext or the authentication tag appear to be invalid it returns an error.\n\n<br>\n\n### Random password generation\n\n<div class=\"codeBox\">\n\n```javascript\nlet password = sodium.to_base64(\n  sodium.randombytes_buf(16),\n  sodium.base64_variants.URLSAFE_NO_PADDING\n);\nreturn password;\n```\n\n</div>\n\nThe `randombytes_buf()` function fills 128 bits starting at buf with an unpredictable sequence of bytes.\n\nThe `to_base64()` function encodes buf as a Base64 string without padding.\n\n<br>\n\n### Keys generation and exchange\n\n<div class=\"codeBox\">\n\n```javascript\nconst keyPair = sodium.crypto_kx_keypair();\nlet keys = {\n  publicKey: sodium.to_base64(keyPair.publicKey),\n  privateKey: sodium.to_base64(keyPair.privateKey),\n};\nreturn keys;\n```\n</div>\n\nThe `crypto_kx_keypair()` function randomly generates a secret key and a corresponding public key. The public key is put into publicKey and the secret key into privateKey. both of 256 bits.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet key = sodium.crypto_kx_client_session_keys(\n  sodium.crypto_scalarmult_base(privateKey),\n  privateKey,\n  publicKey\n);\n```\n</div>\n\nUsing the key exchange API, two parties can securely compute a set of shared keys using their peer's public key and their own secret key.\n\nThe `crypto_kx_client_session_keys()` function computes a pair of 256 bits long shared keys using the recipient's public key, the sender's private key.\n\nThe `crypto_scalarmult_base()` function used to compute the sender's public key from their private key.\n\n<br>\n\n### XChaCha20-Poly1305\n\nXChaCha20 is a variant of ChaCha20 with an extended nonce, allowing random nonces to be safe.\n\nXChaCha20 doesn't require any lookup tables and avoids the possibility of timing attacks.\n\nInternally, XChaCha20 works like a block cipher used in counter mode. It uses the HChaCha20 hash function to derive a subkey and a subnonce from the original key and extended nonce, and a dedicated 64-bit block counter to avoid incrementing the nonce after each block.\n\n<br>\n\n### V2 vs V1\n\n- switching to xchacha20poly1305 for symmetric stream encryption and Argon2id for password-based key derivation. instead of AES-256-GCM and PBKDF2.\n- using the libsodium library for all cryptography instead of the WebCryptoApi.\n- in this version, the app doesn't read the whole file in memory. instead, it's sliced into 64MB chunks that are processed one by one.\n- since we are not using any server-side processing, the app registers a fake download URL (/file) that is going to be handled by the service-worker fetch api.\n- if all validations are passed, a new stream is initialized. then, file chunks are transferred from the main app to the\n  service-worker file via messages.\n- each chunk is encrypted/decrypted on it's own and added to the stream.\n- after each chunk is written on disk it is going to be immediately garbage collected by the browser, this leads to never having more than a few chunks in the memory at the same time.\n\n<br>\n\n[//]: # \"links\"\n[xchacha20-poly1305]: https://libsodium.gitbook.io/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction\n[argon2id]: https://github.com/p-h-c/phc-winner-argon2\n[x25519]: https://cr.yp.to/ecdh.html\n[opensource]: https://github.com/sh-dv/hat.sh\n[bitwarden]: https://bitwarden.com/\n[extending the salsa20 nonce paper]: https://cr.yp.to/snuffle/xsalsa-20081128.pdf\n[soon]: https://tools.ietf.org/html/draft-irtf-cfrg-xchacha\n[github]: https://github.com/sh-dv/hat.sh\n[veracrypt]: https://veracrypt.fr\n[cryptomator]: https://cryptomator.org\n[kryptor]: https://github.com/samuel-lucas6/Kryptor\n[gpg]: https://gnupg.org\n[docker hub]: https://hub.docker.com/r/shdv/hat.sh\n"},{"lang":"ru_RU","content":"# [Вступление](#вступление)\n\n---\n\nHat.sh это свободное [opensource] веб-приложение, которое  обеспечивает безопасное шифрование файлов в браузере.\n\n<br>\n\n# [Возможности](#возможности)\n\n---\n\n### Криптография\n\n- [XChaCha20-Poly1305] - для симметричного шифрования .\n- [Argon2id] - для получения ключа на основе пароля.\n- [X25519] - для обмена ключами.\n\nБиблиотека libsodium используется для всех криптографических алгоритмов. [Технические подробности здесь](#технические-детали).\n\n<br>\n\n### Конфиденциальность\n\n- Приложение работает локально в вашем браузере.\n- Никакие данные никогда не собираются и никому не отправляются.​\n\n<br>\n\n### Функциональность\n\n- Безопасное шифрование/дешифрование файлов с помощью паролей или ключей.\n- Безопасная генерация случайных паролей.\n- Генерация пары асимметричных ключей.\n- Аутентифицированный обмен ключами.\n- Оценка надежности пароля.\n\n<br>\n\n# [Установка](#установка)\n\n---\nСамостоятельно разместить и развернуть hat.sh легко: Вы можете сделать это либо с помощью npm, либо с помощью docker.\n\nЕсли вы хотите разместить приложение у себя, следуйте этим инструкциям:\n\n<br>\n\n## С помощью npm\n\nПеред установкой убедитесь, что вы используете [nodejs](https://nodejs.org/en/) в котором установлен [npm](https://www.npmjs.com/)\n\n<br >\n\n1. клонируйте репозиторий на гитхабе\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. перейдите в папку\n\n```bash\ncd hat.sh\n```\n\n3. установите зависимости\n\n```bash\nnpm install\n```\n\n4. скомпилируйте приложение\n\n```bash\nnpm run build\n```\n\n5. запустите hat.sh\n\n```bash\nnpm run start\n```\n\nприложение должно запуститься и использовать порт 3391.\n<br>\n\nесли вы хотите запустить приложение в среде разработки, запустите:\n\n<br>\n\n```bash\nnpm run dev\n```\n\n<br>\n\n## С помощью docker\n\nВы можете установить приложение с помощью docker несколькими способами. Вы вольны выбирать, какой метод вам нравится.\n\n<br>\n\n- #### установка из docker hub \n\n1. загрузите образ из docker hub\n\n```bash\ndocker pull shdv/hat.sh:latest\n```\n\n2. запустите контейнер\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Собрать образ из исходников\n\n1. клонируйте репозиторий на гитхабе\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. перейдите в папку\n\n```bash\ncd hat.sh\n```\n\n3. соберите образ с помощью docker\n\n```bash\ndocker build . -t shdv/hat.sh\n```\n\n4. запустите контейнер\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### С помощью docker compose\n\n1. клонируйте репозиторий на гитхабе\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. перейдите в папку\n\n```bash\ncd hat.sh\n```\n\n3. соберите образ с помощью docker compose\n\n```bash\ndocker compose build\n```\n\n4. запустите контейнер\n\n```bash\ndocker compose up\n```\n\n<br>\n\nприложение должно запуститься и использовать порт 3391.\n\nhat.sh также доступно в виде образа Docker. Вы можете найти его на [Docker Hub].\n\n<br>\n\n\n# [Использование](#использование)\n\n---\n\n## Зашифровка файлов\n\n- ### используя пароль\n\n1. Откройте hat.sh\n2. Перейдите на панель Зашифровка.\n3. Перетащите или Выберите файлы для зашифровки.\n4. Введите или сгенерируйте пароль.\n5. Скачайте зашифрованный файл.\n\n> Всегда используйте надежный пароль!\n\n- ### используя публичный и приватный ключи\n\n1. Откройте hat.sh\n2. Перейдите на панель Зашифровка.\n3. Перетащите или Выберите файлы для зашифровки.\n4. Выберите метод для публичного ключа.\n5. Введите или загрузите публичный ключ получателя и Ваш приватный ключ.\n   если у Вас нет открытого и закрытого ключей - Вы можете сгенерировать их пару.\n6. Скачайте зашифрованный файл.\n7. Поделитесь своим публичным ключом с получателем, чтобы он смог расшифровать файл.\n\n> Никогда никому не показывайте Ваш приватный ключ! Обмениваться можно только публичными ключами\n\n<br>\n\n## Расшифровка файлов\n\n- ### используя пароль\n\n1. Откройте hat.sh\n2. Перейдите на панель Расшифровка.\n3. Перетащите или Выберите файлы для расшифровки.\n4. Введите пароль.\n5. Скачайте расшифрованный файл.\n\n- ### используя публичный и приватный ключи\n\n1. Откройте hat.sh\n2. Перейдите на панель Расшифровка.\n3. Перетащите или Выберите файлы для расшифровки.\n4. Введите или загрузите публичный ключ отправителя и Ваш приватный ключ.\n5. Скачайте расшифрованный файл.\n\n<br>\n\n# [Ограничения](#ограничения)\n\n---\n\n### Сигнатура файла\n\nФайлы, зашифрованные с помощью hat.sh, можно идентифицировать, изучив сигнатуру файла, которая используется приложением для проверки содержимого файла. Такие сигнатуры также известны как магические числа или Магические Байты. Эти байты аутентифицированы и не могут быть изменены.\n\n### Браузер Safari и Мобильные браузеры\n\nБраузер Safari и Мобильные браузеры имеют ограничения в один файл с максимальным размером 1 ГБ - из-за некоторых проблем, связанных с service-workers. Кроме того, это ограничение также применяется, когда приложению не удается зарегистрировать service-worker (например, Приватный Просмотр FireFox).\n\n<br>\n\n# [Рекомендации](#рекомендации)\n\n---\n\n### Выбор Пароля\n\nБольшинство людей с трудом придумывают и запоминают пароли, что приводит к использованию слабых паролей и повторному использованию паролей. В результате такой неправильной практики шифрование на основе паролей становится значительно менее надёжно. Вот почему рекомендуется использовать встроенный генератор паролей и использовать менеджер паролей, такой как [Bitwarden], где вы можете хранить пароль безопасно.\n\n\nЕсли вы хотите выбрать пароль, который сможете запомнить, то вам следует ввести пароль-фразу из 8 и более слов.\n\n<br>\n\n### Использование шифрования с публичным ключом вместо пароля\n\nЕсли вы шифруете файл, которым собираетесь поделиться с кем-то другим, Вам, вероятно, следует зашифровать его с помощью открытого ключа получателя и Вашего закрытого ключа.\n\n<br>\n\n### Обмен Зашифрованными Файлами\n\nЕсли вы планируете отправить кому-либо зашифрованный файл, рекомендуется использовать ваш приватный ключ и его публичный ключ для шифрования файла.\n\nФайл можно передать через любое безопасное приложение для обмена файлами.\n\n<br>\n\n### Обмен публичными ключами\n\nПубличные ключи можно передавать другим, их можно отправить в виде файла `.public` или простым текстом.\n\n> Никогда никому не показывайте Ваш приватный ключ! Обмениваться можно только публичными ключами.\n\n<br>\n\n### Хранение Публичного и Приватного ключей\n\nХраните ключи шифрования в надежном месте и сделайте резервную копию на внешнее хранилище.\n\nНе рекомендуется хранить приватный ключ в облачном хранилище!\n\n<br>\n\n### Передача Пароля\n\nПоделиться паролем для расшифровки можно с помощью безопасного приложения для обмена сообщениями со сквозным шифрованием. Рекомендуется использовать функцию _Исчезающие Сообщения_ и удалять пароль после того, как получатель расшифрует файл.\n\n> Никогда не используйте один и тот же пароль для разных файлов.\n\n<br>\n\n# [ЧАВО](#чаво)\n\n---\n\n### Регистрирует или хранит ли приложение какие-либо мои данные?\n\nНет, hat.sh никогда не хранит ваши данные. Оно работает только локально в вашем браузере.\n\n<hr style=\"height: 1px\">\n\n### Бесплатен ли hat.sh?\n\nДа, Hat.sh бесплатен и всегда будет таким. Впрочем, пожалуйста, задумайтесь о том, чтобы внести [небольшой взнос](https://github.com/sh-dv/hat.sh#donations) для поддержки проекта.\n\n<hr style=\"height: 1px\">\n\n### Какие типы файлов поддерживаются? Есть ли ограничение на размер файла?\n\nHat.sh принимает все типы файлов. Размер файла не ограничен, что означает, что файлы любого размера могут быть зашифрованы.\n\nБраузер Safari и Мобильные браузеры имеют ограничения в один файл с максимальным размером 1 ГБ.\n\n<hr style=\"height: 1px\">\n\n### Я забыл свой пароль, могу ли я как-то расшифровать свои файлы?\n\nНет, мы не знаем Вашего пароля. Всегда храните свои пароли в менеджере паролей.\n\n<hr style=\"height: 1px\">\n\n### Почему я вижу уведомление \"Действуют ограничения (один файл, 1 ГБ)\"?\n\nЭто означает, что ваш браузер не поддерживает API-интерфейс server-worker fetch. Следовательно, Вы ограничены файлами небольшого размера. См. [Ограничения](#ограничения) для получения дополнительной информации.\n\n<hr style=\"height: 1px\" id=\"why-need-private-key\">\n\n### Безопасно ли делиться своим публичным ключом?\n\nДа. Публичные ключи можно передавать другим, их можно отправить в виде файла `.public` или простым текстом.\n\nНо никому никогда не давайте Ваш приватный ключ!\n\n<hr style=\"height: 1px\">\n\n### Почему приложение запрашивает мой приватный ключ в режиме шифрования с публичным ключом?\n\nHat.sh использует аутентифицированное шифрование. Отправитель должен предоставить свой приватный ключ, из обоих ключей будет вычислен новый общий ключ для шифрования файла. Получатель также должен предоставить свой приватный ключ при расшифровке. Tак можно гарантировать, что зашифрованный файл не был подделан и был отправлен настоящим отправителем.\n\n<hr style=\"height: 1px\">\n\n### Я потерял мой приватный ключ, можно ли его восстановить?\n\nНеа. Потерянные закрытые ключи не могут быть восстановлены.\n\nКроме того, если Вы считаете, что Ваш приватный ключ был скомпрометирован (например, приватный ключ был случайно переслан/показан кому-то или Ваш компьютер был взломан), то Вы должны расшифровать все файлы, которые были зашифрованы с помощью этого ключа, сгенерировать новую пару ключей и повторно зашифровать файлы.\n\n<hr style=\"height: 1px\">\n\n### Как сгенерировать пару ключей (Публичный и Приватный)?\n\nВы можете сгенерировать ключи, посетив [страницу создания ключей](https://hat.sh/generate-keys), не забудьте [хранить ключи безопасно](#рекомендации).\n\n<hr style=\"height: 1px\">\n\n### Измеряет ли приложение надежность пароля?\n\nМы используем JS реализацию [zxcvbn](https://github.com/dropbox/zxcvbn) для проверки энтропии вводимого пароля, эта энтропия будет преобразована в оценку, которая будет отображаться на экране.\n\n<hr style=\"height: 1px\">\n\n### Подключается ли приложение к Интернету?\n\nКак только вы заходите на сайт и страница загружается, она работает полностью офлайн.\n\n<hr style=\"height: 1px\">\n\n### Как я могу внести свой вклад?\n\nHat.sh это приложение с открытым исходным кодом. Вы можете помочь сделать его лучше, сделав коммиты на GitHub. Проект поддерживается в мое свободное время. [Пожертвования](https://github.com/sh-dv/hat.sh#donations) любого размера приветствуются.\n\n<hr style=\"height: 1px\">\n\n### Как сообщить об ошибках? \n\nПожалуйста, сообщайте об ошибках через [Github], открывая проблему с пометкой \"bug\".\n\n<hr style=\"height: 1px\">\n\n### Как сообщить об уязвимости в системе безопасности?\n\nЕсли вы обнаружите действительную проблему безопасности, напишите письмо по адресу hatsh-security@pm.me.\n\nНа данный момент наград за находки нет, но ваша учетная запись github будет указана в разделе благодарностей в документации приложения.\n\n<hr style=\"height: 1px\">\n\n### Почему я должен использовать hat.sh? \n\n1. Приложение использует быстрые современные безопасные криптографические алгоритмы.\n2. Оно очень быстрое и простое в использовании.\n3. Работает в браузере, ничего настраивать и устанавливать не нужно.\n4. Это бесплатное программное обеспечение с открытым исходным кодом, которое можно легко разместить самостоятельно.\n\n<hr style=\"height: 1px\">\n\n### Когда мне не следует использовать hat.sh?\n\n1. Если вы хотите зашифровать диск (лучше используйте, к примеру, [VeraCrypt]).\n2. Если вы хотите часто получать доступ к зашифрованным файлам (лучше используйте, к примеру, [Cryptomator]).\n3. Если вы хотите шифровать и подписывать файлы в одном инструменте. (лучше используйте, к примеру, [Kryptor]).\n4. Если вы предпочитаете инструмент командной строки (лучше используйте, к примеру, [Kryptor]).\n5. Если вам нужно что-то, что соответствует отраслевым стандартам, используйте [GPG].\n\n<br>\n\n# [Технические детали](#технические-детали)\n\n---\n\n### Хэширование паролей и Генерация ключей\n\nФункции хеширования паролей получают секретный ключ любого размера из пароля и соли.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet salt = sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);\nlet key = sodium.crypto_pwhash(\n  sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES,\n  password,\n  salt,\n  sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_ALG_ARGON2ID13\n);\n```\n\n</div>\n\nФункция `crypto_pwhash()` извлекает ключ длиной 256 бит из пароля и соли, фиксированная длина которой составляет 128 бит, что должно быть непредсказуемым.\n\n`randombytes_buf()` — это самый простой способ заполнить 128 бит соли.\n\n<br>\n\n`OPSLIMIT` определяет максимальный лимит операций вычисления.\n\n`MEMLIMIT` это максимальный объем ОЗУ, который будет использовать функция, в байтах.\n\n<br>\n\n`crypto_pwhash_OPSLIMIT_INTERACTIVE` и `crypto_pwhash_MEMLIMIT_INTERACTIVE` определяют значения по умолчанию для этих двух параметров. В настоящее время для этого требуется 64 МБ выделенной оперативной памяти. Что подходит для операций в браузере.\n<br>\n`crypto_pwhash_ALG_ARGON2ID13` использует алгоритм Argon2id версии 1.3.\n\n<br>\n\n### Зашифровка файлов (потоковая)\n\nЧтобы использовать приложение для шифрования файла, пользователь должен предоставить валидный файл и пароль. Этот пароль хешируется, и хеш используется Argon2id чтобы вычислить безопасный ключ для шифрования файла.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet res = sodium.crypto_secretstream_xchacha20poly1305_init_push(key);\nheader = res.header;\nstate = res.state;\n\nlet tag = last\n  ? sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL\n  : sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;\n\nlet encryptedChunk = sodium.crypto_secretstream_xchacha20poly1305_push(\n  state,\n  new Uint8Array(chunk),\n  null,\n  tag\n);\n\nstream.enqueue(signature, salt, header, encryptedChunk);\n```\n\n</div>\n\nФункция `crypto_secretstream_xchacha20poly1305_init_push` создает зашифрованный поток, в котором инициализируется состояние `state` с помощью ключа и внутреннего, автоматически сгенерированного вектора инициализации. Затем он сохраняет заголовок потока в `header` размером 192 бита.\n\nЭто первая функция, вызываемая для создания зашифрованного потока. Ключ больше не потребуется для последующих операций.\n\n<br>\n\nЗашифрованный поток начинается с короткого заголовка, размер которого составляет 192 бита. Этот заголовок должен быть отправлен/сохранен перед последовательностью зашифрованных сообщений, так как он необходим для расшифровки потока. Содержимое заголовка не обязательно должно быть секретным, потому что расшифровка с другим заголовком завершится неудачей.\n\nТег прикрепляется к каждому сообщению в соответствии со значением `last`, которое указывает, является ли это последним фрагментом файла или нет. Этот тег может быть любым из:\n\n1. `crypto_secretstream_xchacha20poly1305_TAG_MESSAGE`: Это не добавляет никакой информации о характере сообщения.\n2. `crypto_secretstream_xchacha20poly1305_TAG_FINAL`: Это указывает на то, что сообщение отмечает конец потока и стирает секретный ключ, используемый для шифрования предыдущей последовательности.\n\nФункция `crypto_secretstream_xchacha20poly1305_push()` шифрует фрагмент `chunk` файла, используя `state` и `tag`, без какой-либо дополнительной информации (`null`).\n<br>\n\nдля шифрования используется потоковый шифр XChaCha20 с аутентификацией Poly1305 MAC.\n\nфункция `stream.enqueue()` добавляет подпись hat.sh (магические байты), соль и заголовок, за которыми следуют зашифрованные фрагменты.\n\n### Расшифровка файлов (потоковая)\n\n<div class=\"codeBox\">\n\n```javascript\nlet state = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n\nlet result = sodium.crypto_secretstream_xchacha20poly1305_pull(\n  state,\n  new Uint8Array(chunk)\n);\n\nif (result) {\n  let decryptedChunk = result.message;\n  stream.enqueue(decryptedChunk);\n\n  if (!last) {\n    // continue decryption\n  }\n}\n```\n\n</div>\n\nФункция `crypto_secretstream_xchacha20poly1305_init_pull()` инициализирует состояние `state` с помощью секретного `key` и `header`. Ключ вычисляется из пароля, предоставленного во время расшифровки, и заголовка, нарезанного из файла. Ключ больше не потребуется для последующих операций.\n\n<br>\n\nФункция `crypto_secretstream_xchacha20poly1305_pull()` проверяет, что фрагмент `chunk` содержит валидный зашифрованный текст и тег аутентификации для данного состояния `state`.\n\nЭта функция будет оставаться в цикле, пока не будет найдено сообщение с тегом `crypto_secretstream_xchacha20poly1305_TAG_FINAL`.\n\nЕсли ключ расшифровки неверный, функция возвращает ошибку.\n\nЕсли зашифрованный текст или тег аутентификации кажутся недействительными, возвращается ошибка.\n\n<br>\n\n### Генерация случайных паролей\n\n<div class=\"codeBox\">\n\n```javascript\nlet password = sodium.to_base64(\n  sodium.randombytes_buf(16),\n  sodium.base64_variants.URLSAFE_NO_PADDING\n);\nreturn password;\n```\n\n</div>\n\nФункция randombytes_buf() заполняет 128 битов, начиная с buf, непредсказуемой последовательностью байтов.\n\nФункция to_base64() кодирует buf как строку Base64 без заполнения.\n\n<br>\n\n### Генерация и обмен ключами\n\n<div class=\"codeBox\">\n\n```javascript\nconst keyPair = sodium.crypto_kx_keypair();\nlet keys = {\n  publicKey: sodium.to_base64(keyPair.publicKey),\n  privateKey: sodium.to_base64(keyPair.privateKey),\n};\nreturn keys;\n```\n</div>\n\nФункция `crypto_kx_keypair()` случайным образом генерирует секретный ключ и соответствующий открытый ключ. Открытый ключ помещается в публичный ключ publicKey, а секретный ключ — в приватный ключ privateKey. Оба по 256 бит.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet key = sodium.crypto_kx_client_session_keys(\n  sodium.crypto_scalarmult_base(privateKey),\n  privateKey,\n  publicKey\n);\n```\n</div>\n\nИспользуя API обмена ключей, две стороны могут безопасно вычислить набор общих ключей, используя публичный ключ своего партнера и свой собственный секретный (приватный) ключ.\n\nФункция `crypto_kx_client_session_keys()` вычисляет пару общих ключей длиной 256 бит, используя публичный ключ получателя и приватный ключ отправителя.\n\nФункция `crypto_scalarmult_base()` используется для вычисления публичного ключа отправителя из его приватного ключа.\n\n<br>\n\n### XChaCha20-Poly1305\n\nXChaCha20 - это вариант ChaCha20 с расширенным nonce, позволяющий случайным nonce быть безопасными.\n\nXChaCha20 не требует никаких таблиц поиска и позволяет избежать атак по времени.\n\nВнутри XChaCha20 работает как блочный шифр, используемый в режиме счетчика. Он использует хеш-функцию HChaCha20 для получения subkey и subnonce из исходного ключа и расширенного nonce, а также специальный 64-битный счетчик блоков, чтобы избежать увеличения nonce после каждого блока.\n\n<br>\n\n### отличия V2 от V1\n\n- переход на xchacha20poly1305 для симметричного потокового шифрования и Argon2id для получения ключа на основе пароля. вместо AES-256-GCM и PBKDF2.\n- применение библиотеки libsodium для всей криптографии вместо WebCryptoApi.\n- в этой версии приложение не читает весь файл в память. вместо этого файл нарезается на фрагменты по 64 МБ, которые обрабатываются один за другим.\n- поскольку мы не используем какую-либо обработку на стороне сервера, приложение регистрирует поддельный URL-адрес загрузки (/file), который будет обрабатываться API-интерфейсом service-worker.\n- если все проверки пройдены, инициализируется новый поток. затем фрагменты файла передаются из основного приложения в \n  файл service-worker с помощью сообщений.\n- каждый фрагмент шифруется/дешифруется отдельно и добавляется в поток.\n- после того как каждый фрагмент записывается на диск, он будет удалён сборщиком мусора в браузере, и это приводит к тому, что в памяти никогда не бывает больше нескольких фрагментов одновременно.\n\n<br>\n\n[//]: # \"ссылки\"\n[xchacha20-poly1305]: https://libsodium.gitbook.io/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction\n[argon2id]: https://github.com/p-h-c/phc-winner-argon2\n[x25519]: https://cr.yp.to/ecdh.html\n[opensource]: https://github.com/sh-dv/hat.sh\n[bitwarden]: https://bitwarden.com/\n[extending the salsa20 nonce paper]: https://cr.yp.to/snuffle/xsalsa-20081128.pdf\n[soon]: https://tools.ietf.org/html/draft-irtf-cfrg-xchacha\n[github]: https://github.com/sh-dv/hat.sh\n[veracrypt]: https://veracrypt.fr\n[cryptomator]: https://cryptomator.org\n[kryptor]: https://github.com/samuel-lucas6/Kryptor\n[gpg]: https://gnupg.org\n[docker hub]: https://hub.docker.com/r/shdv/hat.sh\n"},{"lang":"it_IT","content":"# [Introduction](#introduction)\n\n---\n\nHat.sh is a free [opensource] web app that provides secure file encryption in the browser.\n\n<br>\n\n# [Features](#features)\n\n---\n\n### Security\n\n- [XChaCha20-Poly1305] - for symmetric encryption.\n- [Argon2id] - for password-based key derivation.\n- [X25519] - for key exchange.\n\nThe libsodium library is used for all cryptographic algorithms. [Technical details here](#technical-details).\n\n<br>\n\n### Privacy\n\n- The app runs locally in your browser.\n- No data is ever collected or sent to anyone.​\n\n<br>\n\n### Functionality\n\n- Secure encryption/decryption of files with passwords or keys.\n- Secure random password generation.\n- Asymmetric key pair generation.\n- Authenticated key exchange.\n- Password strength estimation.\n\n<br>\n\n# [Installation](#installation)\n\n---\nIt's easy to self host and deploy hat.sh, you can do that either with npm or docker\n\nIf you wish to self host the app please follow these instructions:\n\n<br>\n\n## With npm\n\nBefore installation make sure you are running [nodejs](https://nodejs.org/en/) and have [npm](https://www.npmjs.com/) installed\n\n<br >\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. install dependencies\n\n```bash\nnpm install\n```\n\n4. build app\n\n```bash\nnpm run build\n```\n\n5. start hat.sh\n\n```bash\nnpm run start\n```\n\nthe app should be running on port 3391.\n<br>\n\nif you wish to run the app in development enviroment run :\n\n<br>\n\n```bash\nnpm run dev\n```\n\n<br>\n\n## With docker\n\nYou can install the app with docker in multiple ways. You are free to choose which method you like.\n\n<br>\n\n- #### install from docker hub\n\n1. pull image from docker hub\n\n```bash\ndocker pull shdv/hat.sh:latest\n```\n\n2. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Build an image from source\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker\n\n```bash\ndocker build . -t shdv/hat.sh\n```\n\n4. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Using docker compose\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker compose\n\n```bash\ndocker compose build\n```\n\n4. run container\n\n```bash\ndocker compose up\n```\n\n<br>\n\nThe app should be running on port 3991.\n\nhat.sh is also available as a Docker image. You can find it on [Docker Hub].\n\n<br>\n\n\n# [Usage](#usage)\n\n---\n\n## File Encryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Enter a password or generate one.\n5. Download the encrypted file.\n\n> You should always use a strong password!\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Choose public key method.\n5. Enter or load recipient's public key and your private key.\n   if you don't have public and private keys you can generate a key pair.\n6. Download the encrypted file.\n7. Share your public key with the recipient so he will be able to decrypt the file.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n## File Decryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter the encryption password.\n5. Download the decrypted file.\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter or load sender's public key and your private key.\n5. Download the decrypted file.\n\n<br>\n\n# [Limitations](#limitations)\n\n---\n\n### File Signature\n\nFiles encrypted with hat.sh are identifiable by looking at the file signature that is used by the app to verify the content of a file, Such signatures are also known as magic numbers or Magic Bytes. These Bytes are authenticated and cannot be changed.\n\n### Safari and Mobile Browsers\n\nSafari and Mobile browsers are limited to a single file with maximum size of 1GB due to some issues related to service-workers. In addition, this limitation also applies when the app fails to register the service-worker (e.g FireFox Private Browsing).\n\n<br>\n\n# [Best Practices](#best-practices)\n\n---\n\n### Choosing Passwords\n\nThe majority of individuals struggle to create and remember passwords, resulting in weak passwords and password reuse. Password-based encryption is substantially less safe as a result of these improper practices. That's why it is recommended to use the built in password generator and use a password manager like [Bitwarden], where you are able to store the safe password.\n\n\nIf you want to choose a password that you are able to memorize then you should type a passphrase made of 8 words or more.\n\n<br>\n\n### Using public key encryption instead of a password\n\nIf you are encrypting a file that you are going to share it with someone else then you probably should encrypt it with the recipient public key and your private key.\n\n<br>\n\n### Sharing Encrypted Files\n\nIf you plan on sending someone an encrypted file, it is recommended to use your private key and their public key to encrypt the file.\n\nThe file can be shared in any safe file sharing app.\n\n<br>\n\n### Sharing the public key\n\nPublic keys are allowed to be shared, they can be sent as `.public` file or as text.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n### Storing the Public & Private keys\n\nMake sure to store your encryption keys in a safe place and make a backup to an external storage.\n\nStoring your private key in cloud storage is not recommended!\n\n<br>\n\n### Sharing Decryption Passwords\n\nSharing decryption password can be done using a safe end-to-end encrypted messaging app. It's recommended to use a _Disappearing Messages_ feature, and to delete the password after the recipient has decrypted the file.\n\n> Never choose the same password for different files.\n\n<br>\n\n# [FAQ](#faq)\n\n---\n\n### Does the app log or store any of my data?\n\nNo, hat.sh never stores any of your data. It only runs locally in your browser.\n\n<hr style=\"height: 1px\">\n\n### Is hat.sh free?\n\nYes, Hat.sh is free and always will be. However, please consider [donating](https://github.com/sh-dv/hat.sh#donations) to support the project.\n\n<hr style=\"height: 1px\">\n\n### Which file types are supported? Is there a file size limit?\n\nHat.sh accepts all file types. There's no file size limit, meaning files of any size can be encrypted.\n\nSafari browser and mobile/smartphones browsers are limited to 1GB.\n\n<hr style=\"height: 1px\">\n\n### I forgot my password, can I still decrypt my files?\n\nNo, we don't know your password. Always make sure to store your passwords in a password manager.\n\n<hr style=\"height: 1px\">\n\n### Why am I seeing a notice that says \"You have limited experience (single file, 1GB)\"?\n\nIt means that your browser doesn't support the server-worker fetch api. Hence, you are limited to small size files. see [Limitations](#limitations) for more info.\n\n<hr style=\"height: 1px\" id=\"why-need-private-key\">\n\n### Is it safe to share my public key?\n\nYes. Public keys are allowed to be shared, they can be sent as `.public` file or as text.\n\nBut make sure to never share your private key with anyone!\n\n<hr style=\"height: 1px\">\n\n### Why the app asks for my private key in the public key encryption mode?\n\nHat.sh uses authenticated encryption. The sender must provide their private key, a new shared key will be computed from both keys to encrypt the file. Recipient has to provide their private key when decrypting also. this way can verify that the encrypted file was not tampered with, and was sent from the real sender.\n\n<hr style=\"height: 1px\">\n\n### I have lost my private key, is it possible to recover it?\n\nNope. lost private keys cannot be recovered.\n\nAlso, if you feel that your private key has been compromised (e.g accidentally shared / computer hacked) then you must decrypt all files that were encrypted with that key, generate a new keypair and re-encrypt the files.\n\n<hr style=\"height: 1px\">\n\n### How do I generate a keypair (Public & Private)?\n\nYou can generate keys by visit the [key generate page](https://hat.sh/generate-keys), make sure to [store the keys safely](#best-practices).\n\n<hr style=\"height: 1px\">\n\n### Does the app measure password strength?\n\nWe use [zxcvbn](https://github.com/dropbox/zxcvbn) JS implementation to check the entropy of the password input, this entropy will be converted to score that will be displayed on screen.\n\n<hr style=\"height: 1px\">\n\n### Does the app connect to the internet?\n\nOnce you visit the site and the page loads, it runs only offline.\n\n<hr style=\"height: 1px\">\n\n### How can I contribute?\n\nHat.sh is an open-source application. You can help make it better by making commits on GitHub. The project is maintained in my free time. [Donations](https://github.com/sh-dv/hat.sh#donations) of any size are appreciated.\n\n<hr style=\"height: 1px\">\n\n### How do I report bugs?\n\nPlease report bugs via [Github] by opening an issue labeled with \"bug\".\n\n<hr style=\"height: 1px\">\n\n### How do I report a security vulnerability?\n\nIf you identify a valid security issue, please write an email to hatsh-security@pm.me\n\nThere is no bounty available at the moment, but your github account will be credited in the acknowledgements section in the app documentation.\n\n<hr style=\"height: 1px\">\n\n### Why should I use hat.sh?\n\n1. The app uses fast modern secure cryptographic algorithms.\n2. It's super fast and easy to use.\n3. It runs in the browser, no need to setup or install anything.\n4. It's free opensource software and can be easily self hosted.\n\n<hr style=\"height: 1px\">\n\n### When should I not use hat.sh?\n\n1. If you want to encrypt a disk (e.g [VeraCrypt]).\n2. If you want to frequently access encrypted files (e.g [Cryptomator]).\n3. If you want to encrypt and sign files in the same tool. (e.g [Kryptor]).\n4. If you prefer a command line tool (e.g [Kryptor]).\n5. If you want something that adheres to industry standards, use [GPG].\n\n<br>\n\n# [Technical Details](#technical-details)\n\n---\n\n### Password hashing and Key derivation\n\nPassword hashing functions derive a secret key of any size from a password and a salt.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet salt = sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);\nlet key = sodium.crypto_pwhash(\n  sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES,\n  password,\n  salt,\n  sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_ALG_ARGON2ID13\n);\n```\n\n</div>\n\nThe `crypto_pwhash()` function derives an 256 bits long key from a password and a salt salt whose fixed length is 128 bits, which should be unpredictable.\n\n`randombytes_buf()` is the easiest way to fill the 128 bits of the salt.\n\n<br>\n\n`OPSLIMIT` represents a maximum amount of computations to perform.\n\n`MEMLIMIT` is the maximum amount of RAM that the function will use, in bytes.\n\n<br>\n\n`crypto_pwhash_OPSLIMIT_INTERACTIVE` and `crypto_pwhash_MEMLIMIT_INTERACTIVE` provide base line for these two parameters. This currently requires 64 MiB of dedicated RAM. which is suitable for in-browser operations.\n<br>\n`crypto_pwhash_ALG_ARGON2ID13` using the Argon2id algorithm version 1.3.\n\n<br>\n\n### File Encryption (stream)\n\nIn order to use the app to encrypt a file, the user has to provide a valid file and a password. this password gets hashed and a secure key is derived from it with Argon2id to encrypt the file.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet res = sodium.crypto_secretstream_xchacha20poly1305_init_push(key);\nheader = res.header;\nstate = res.state;\n\nlet tag = last\n  ? sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL\n  : sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;\n\nlet encryptedChunk = sodium.crypto_secretstream_xchacha20poly1305_push(\n  state,\n  new Uint8Array(chunk),\n  null,\n  tag\n);\n\nstream.enqueue(signature, salt, header, encryptedChunk);\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_push` function creates an encrypted stream where it initializes a `state` using the key and an internal, automatically generated initialization vector. It then stores the stream header into `header` that has a size of 192 bits.\n\nThis is the first function to call in order to create an encrypted stream. The key will not be required any more for subsequent operations.\n\n<br>\n\nAn encrypted stream starts with a short header, whose size is 192 bits. That header must be sent/stored before the sequence of encrypted messages, as it is required to decrypt the stream. The header content doesn't have to be secret because decryption with a different header would fail.\n\nA tag is attached to each message accoring to the value of `last`, which indicates if that is the last chunk of the file or not. That tag can be any of:\n\n1. `crypto_secretstream_xchacha20poly1305_TAG_MESSAGE`: This doesn't add any information about the nature of the message.\n2. `crypto_secretstream_xchacha20poly1305_TAG_FINAL`: This indicates that the message marks the end of the stream, and erases the secret key used to encrypt the previous sequence.\n\nThe `crypto_secretstream_xchacha20poly1305_push()` function encrypts the file `chunk` using the `state` and the `tag`, without any additional information (`null`).\n<br>\n\nthe XChaCha20 stream cipher Poly1305 MAC authentication are used for encryption.\n\n`stream.enqueue()` function adds the hat.sh signature(magic bytes), salt and header followed by the encrypted chunks.\n\n### File Decryption (stream)\n\n<div class=\"codeBox\">\n\n```javascript\nlet state = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n\nlet result = sodium.crypto_secretstream_xchacha20poly1305_pull(\n  state,\n  new Uint8Array(chunk)\n);\n\nif (result) {\n  let decryptedChunk = result.message;\n  stream.enqueue(decryptedChunk);\n\n  if (!last) {\n    // continue decryption\n  }\n}\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_pull()` function initializes a state given a secret `key` and a `header`. The key is derived from the password provided during the decryption, and the header sliced from the file. The key will not be required any more for subsequent operations.\n\n<br>\n\nThe `crypto_secretstream_xchacha20poly1305_pull()` function verifies that the `chunk` contains a valid ciphertext and authentication tag for the given `state`.\n\nThis function will stay in a loop, until a message with the `crypto_secretstream_xchacha20poly1305_TAG_FINAL` tag is found.\n\nIf the decryption key is incorrect the function returns an error.\n\nIf the ciphertext or the authentication tag appear to be invalid it returns an error.\n\n<br>\n\n### Random password generation\n\n<div class=\"codeBox\">\n\n```javascript\nlet password = sodium.to_base64(\n  sodium.randombytes_buf(16),\n  sodium.base64_variants.URLSAFE_NO_PADDING\n);\nreturn password;\n```\n\n</div>\n\nThe `randombytes_buf()` function fills 128 bits starting at buf with an unpredictable sequence of bytes.\n\nThe `to_base64()` function encodes buf as a Base64 string without padding.\n\n<br>\n\n### Keys generation and exchange\n\n<div class=\"codeBox\">\n\n```javascript\nconst keyPair = sodium.crypto_kx_keypair();\nlet keys = {\n  publicKey: sodium.to_base64(keyPair.publicKey),\n  privateKey: sodium.to_base64(keyPair.privateKey),\n};\nreturn keys;\n```\n</div>\n\nThe `crypto_kx_keypair()` function randomly generates a secret key and a corresponding public key. The public key is put into publicKey and the secret key into privateKey. both of 256 bits.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet key = sodium.crypto_kx_client_session_keys(\n  sodium.crypto_scalarmult_base(privateKey),\n  privateKey,\n  publicKey\n);\n```\n</div>\n\nUsing the key exchange API, two parties can securely compute a set of shared keys using their peer's public key and their own secret key.\n\nThe `crypto_kx_client_session_keys()` function computes a pair of 256 bits long shared keys using the recipient's public key, the sender's private key.\n\nThe `crypto_scalarmult_base()` function used to compute the sender's public key from their private key.\n\n<br>\n\n### XChaCha20-Poly1305\n\nXChaCha20 is a variant of ChaCha20 with an extended nonce, allowing random nonces to be safe.\n\nXChaCha20 doesn't require any lookup tables and avoids the possibility of timing attacks.\n\nInternally, XChaCha20 works like a block cipher used in counter mode. It uses the HChaCha20 hash function to derive a subkey and a subnonce from the original key and extended nonce, and a dedicated 64-bit block counter to avoid incrementing the nonce after each block.\n\n<br>\n\n### V2 vs V1\n\n- switching to xchacha20poly1305 for symmetric stream encryption and Argon2id for password-based key derivation. instead of AES-256-GCM and PBKDF2.\n- using the libsodium library for all cryptography instead of the WebCryptoApi.\n- in this version, the app doesn't read the whole file in memory. instead, it's sliced into 64MB chunks that are processed one by one.\n- since we are not using any server-side processing, the app registers a fake download URL (/file) that is going to be handled by the service-worker fetch api.\n- if all validations are passed, a new stream is initialized. then, file chunks are transferred from the main app to the\n  service-worker file via messages.\n- each chunk is encrypted/decrypted on it's own and added to the stream.\n- after each chunk is written on disk it is going to be immediately garbage collected by the browser, this leads to never having more than a few chunks in the memory at the same time.\n\n<br>\n\n[//]: # \"links\"\n[xchacha20-poly1305]: https://libsodium.gitbook.io/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction\n[argon2id]: https://github.com/p-h-c/phc-winner-argon2\n[x25519]: https://cr.yp.to/ecdh.html\n[opensource]: https://github.com/sh-dv/hat.sh\n[bitwarden]: https://bitwarden.com/\n[extending the salsa20 nonce paper]: https://cr.yp.to/snuffle/xsalsa-20081128.pdf\n[soon]: https://tools.ietf.org/html/draft-irtf-cfrg-xchacha\n[github]: https://github.com/sh-dv/hat.sh\n[veracrypt]: https://veracrypt.fr\n[cryptomator]: https://cryptomator.org\n[kryptor]: https://github.com/samuel-lucas6/Kryptor\n[gpg]: https://gnupg.org\n[docker hub]: https://hub.docker.com/r/shdv/hat.sh\n"},{"lang":"sk_SK","content":"# [Introduction](#introduction)\n\n---\n\nHat.sh is a free [opensource] web app that provides secure file encryption in the browser.\n\n<br>\n\n# [Features](#features)\n\n---\n\n### Security\n\n- [XChaCha20-Poly1305] - for symmetric encryption.\n- [Argon2id] - for password-based key derivation.\n- [X25519] - for key exchange.\n\nThe libsodium library is used for all cryptographic algorithms. [Technical details here](#technical-details).\n\n<br>\n\n### Privacy\n\n- The app runs locally in your browser.\n- No data is ever collected or sent to anyone.​\n\n<br>\n\n### Functionality\n\n- Secure encryption/decryption of files with passwords or keys.\n- Secure random password generation.\n- Asymmetric key pair generation.\n- Authenticated key exchange.\n- Password strength estimation.\n\n<br>\n\n# [Installation](#installation)\n\n---\nIt's easy to self host and deploy hat.sh, you can do that either with npm or docker\n\nIf you wish to self host the app please follow these instructions:\n\n<br>\n\n## With npm\n\nBefore installation make sure you are running [nodejs](https://nodejs.org/en/) and have [npm](https://www.npmjs.com/) installed\n\n<br >\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. install dependencies\n\n```bash\nnpm install\n```\n\n4. build app\n\n```bash\nnpm run build\n```\n\n5. start hat.sh\n\n```bash\nnpm run start\n```\n\nthe app should be running on port 3391.\n<br>\n\nif you wish to run the app in development enviroment run :\n\n<br>\n\n```bash\nnpm run dev\n```\n\n<br>\n\n## With docker\n\nYou can install the app with docker in multiple ways. You are free to choose which method you like.\n\n<br>\n\n- #### install from docker hub\n\n1. pull image from docker hub\n\n```bash\ndocker pull shdv/hat.sh:latest\n```\n\n2. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Build an image from source\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker\n\n```bash\ndocker build . -t shdv/hat.sh\n```\n\n4. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Using docker compose\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker compose\n\n```bash\ndocker compose build\n```\n\n4. run container\n\n```bash\ndocker compose up\n```\n\n<br>\n\nThe app should be running on port 3991.\n\nhat.sh is also available as a Docker image. You can find it on [Docker Hub].\n\n<br>\n\n\n# [Usage](#usage)\n\n---\n\n## File Encryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Enter a password or generate one.\n5. Download the encrypted file.\n\n> You should always use a strong password!\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Choose public key method.\n5. Enter or load recipient's public key and your private key.\n   if you don't have public and private keys you can generate a key pair.\n6. Download the encrypted file.\n7. Share your public key with the recipient so he will be able to decrypt the file.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n## File Decryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter the encryption password.\n5. Download the decrypted file.\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter or load sender's public key and your private key.\n5. Download the decrypted file.\n\n<br>\n\n# [Limitations](#limitations)\n\n---\n\n### File Signature\n\nFiles encrypted with hat.sh are identifiable by looking at the file signature that is used by the app to verify the content of a file, Such signatures are also known as magic numbers or Magic Bytes. These Bytes are authenticated and cannot be changed.\n\n### Safari and Mobile Browsers\n\nSafari and Mobile browsers are limited to a single file with maximum size of 1GB due to some issues related to service-workers. In addition, this limitation also applies when the app fails to register the service-worker (e.g FireFox Private Browsing).\n\n<br>\n\n# [Best Practices](#best-practices)\n\n---\n\n### Choosing Passwords\n\nThe majority of individuals struggle to create and remember passwords, resulting in weak passwords and password reuse. Password-based encryption is substantially less safe as a result of these improper practices. That's why it is recommended to use the built in password generator and use a password manager like [Bitwarden], where you are able to store the safe password.\n\n\nIf you want to choose a password that you are able to memorize then you should type a passphrase made of 8 words or more.\n\n<br>\n\n### Using public key encryption instead of a password\n\nIf you are encrypting a file that you are going to share it with someone else then you probably should encrypt it with the recipient public key and your private key.\n\n<br>\n\n### Sharing Encrypted Files\n\nIf you plan on sending someone an encrypted file, it is recommended to use your private key and their public key to encrypt the file.\n\nThe file can be shared in any safe file sharing app.\n\n<br>\n\n### Sharing the public key\n\nPublic keys are allowed to be shared, they can be sent as `.public` file or as text.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n### Storing the Public & Private keys\n\nMake sure to store your encryption keys in a safe place and make a backup to an external storage.\n\nStoring your private key in cloud storage is not recommended!\n\n<br>\n\n### Sharing Decryption Passwords\n\nSharing decryption password can be done using a safe end-to-end encrypted messaging app. It's recommended to use a _Disappearing Messages_ feature, and to delete the password after the recipient has decrypted the file.\n\n> Never choose the same password for different files.\n\n<br>\n\n# [FAQ](#faq)\n\n---\n\n### Does the app log or store any of my data?\n\nNo, hat.sh never stores any of your data. It only runs locally in your browser.\n\n<hr style=\"height: 1px\">\n\n### Is hat.sh free?\n\nYes, Hat.sh is free and always will be. However, please consider [donating](https://github.com/sh-dv/hat.sh#donations) to support the project.\n\n<hr style=\"height: 1px\">\n\n### Which file types are supported? Is there a file size limit?\n\nHat.sh accepts all file types. There's no file size limit, meaning files of any size can be encrypted.\n\nSafari browser and mobile/smartphones browsers are limited to 1GB.\n\n<hr style=\"height: 1px\">\n\n### I forgot my password, can I still decrypt my files?\n\nNo, we don't know your password. Always make sure to store your passwords in a password manager.\n\n<hr style=\"height: 1px\">\n\n### Why am I seeing a notice that says \"You have limited experience (single file, 1GB)\"?\n\nIt means that your browser doesn't support the server-worker fetch api. Hence, you are limited to small size files. see [Limitations](#limitations) for more info.\n\n<hr style=\"height: 1px\" id=\"why-need-private-key\">\n\n### Is it safe to share my public key?\n\nYes. Public keys are allowed to be shared, they can be sent as `.public` file or as text.\n\nBut make sure to never share your private key with anyone!\n\n<hr style=\"height: 1px\">\n\n### Why the app asks for my private key in the public key encryption mode?\n\nHat.sh uses authenticated encryption. The sender must provide their private key, a new shared key will be computed from both keys to encrypt the file. Recipient has to provide their private key when decrypting also. this way can verify that the encrypted file was not tampered with, and was sent from the real sender.\n\n<hr style=\"height: 1px\">\n\n### I have lost my private key, is it possible to recover it?\n\nNope. lost private keys cannot be recovered.\n\nAlso, if you feel that your private key has been compromised (e.g accidentally shared / computer hacked) then you must decrypt all files that were encrypted with that key, generate a new keypair and re-encrypt the files.\n\n<hr style=\"height: 1px\">\n\n### How do I generate a keypair (Public & Private)?\n\nYou can generate keys by visit the [key generate page](https://hat.sh/generate-keys), make sure to [store the keys safely](#best-practices).\n\n<hr style=\"height: 1px\">\n\n### Does the app measure password strength?\n\nWe use [zxcvbn](https://github.com/dropbox/zxcvbn) JS implementation to check the entropy of the password input, this entropy will be converted to score that will be displayed on screen.\n\n<hr style=\"height: 1px\">\n\n### Does the app connect to the internet?\n\nOnce you visit the site and the page loads, it runs only offline.\n\n<hr style=\"height: 1px\">\n\n### How can I contribute?\n\nHat.sh is an open-source application. You can help make it better by making commits on GitHub. The project is maintained in my free time. [Donations](https://github.com/sh-dv/hat.sh#donations) of any size are appreciated.\n\n<hr style=\"height: 1px\">\n\n### How do I report bugs?\n\nPlease report bugs via [Github] by opening an issue labeled with \"bug\".\n\n<hr style=\"height: 1px\">\n\n### How do I report a security vulnerability?\n\nIf you identify a valid security issue, please write an email to hatsh-security@pm.me\n\nThere is no bounty available at the moment, but your github account will be credited in the acknowledgements section in the app documentation.\n\n<hr style=\"height: 1px\">\n\n### Why should I use hat.sh?\n\n1. The app uses fast modern secure cryptographic algorithms.\n2. It's super fast and easy to use.\n3. It runs in the browser, no need to setup or install anything.\n4. It's free opensource software and can be easily self hosted.\n\n<hr style=\"height: 1px\">\n\n### When should I not use hat.sh?\n\n1. If you want to encrypt a disk (e.g [VeraCrypt]).\n2. If you want to frequently access encrypted files (e.g [Cryptomator]).\n3. If you want to encrypt and sign files in the same tool. (e.g [Kryptor]).\n4. If you prefer a command line tool (e.g [Kryptor]).\n5. If you want something that adheres to industry standards, use [GPG].\n\n<br>\n\n# [Technical Details](#technical-details)\n\n---\n\n### Password hashing and Key derivation\n\nPassword hashing functions derive a secret key of any size from a password and a salt.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet salt = sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);\nlet key = sodium.crypto_pwhash(\n  sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES,\n  password,\n  salt,\n  sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_ALG_ARGON2ID13\n);\n```\n\n</div>\n\nThe `crypto_pwhash()` function derives an 256 bits long key from a password and a salt salt whose fixed length is 128 bits, which should be unpredictable.\n\n`randombytes_buf()` is the easiest way to fill the 128 bits of the salt.\n\n<br>\n\n`OPSLIMIT` represents a maximum amount of computations to perform.\n\n`MEMLIMIT` is the maximum amount of RAM that the function will use, in bytes.\n\n<br>\n\n`crypto_pwhash_OPSLIMIT_INTERACTIVE` and `crypto_pwhash_MEMLIMIT_INTERACTIVE` provide base line for these two parameters. This currently requires 64 MiB of dedicated RAM. which is suitable for in-browser operations.\n<br>\n`crypto_pwhash_ALG_ARGON2ID13` using the Argon2id algorithm version 1.3.\n\n<br>\n\n### File Encryption (stream)\n\nIn order to use the app to encrypt a file, the user has to provide a valid file and a password. this password gets hashed and a secure key is derived from it with Argon2id to encrypt the file.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet res = sodium.crypto_secretstream_xchacha20poly1305_init_push(key);\nheader = res.header;\nstate = res.state;\n\nlet tag = last\n  ? sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL\n  : sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;\n\nlet encryptedChunk = sodium.crypto_secretstream_xchacha20poly1305_push(\n  state,\n  new Uint8Array(chunk),\n  null,\n  tag\n);\n\nstream.enqueue(signature, salt, header, encryptedChunk);\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_push` function creates an encrypted stream where it initializes a `state` using the key and an internal, automatically generated initialization vector. It then stores the stream header into `header` that has a size of 192 bits.\n\nThis is the first function to call in order to create an encrypted stream. The key will not be required any more for subsequent operations.\n\n<br>\n\nAn encrypted stream starts with a short header, whose size is 192 bits. That header must be sent/stored before the sequence of encrypted messages, as it is required to decrypt the stream. The header content doesn't have to be secret because decryption with a different header would fail.\n\nA tag is attached to each message accoring to the value of `last`, which indicates if that is the last chunk of the file or not. That tag can be any of:\n\n1. `crypto_secretstream_xchacha20poly1305_TAG_MESSAGE`: This doesn't add any information about the nature of the message.\n2. `crypto_secretstream_xchacha20poly1305_TAG_FINAL`: This indicates that the message marks the end of the stream, and erases the secret key used to encrypt the previous sequence.\n\nThe `crypto_secretstream_xchacha20poly1305_push()` function encrypts the file `chunk` using the `state` and the `tag`, without any additional information (`null`).\n<br>\n\nthe XChaCha20 stream cipher Poly1305 MAC authentication are used for encryption.\n\n`stream.enqueue()` function adds the hat.sh signature(magic bytes), salt and header followed by the encrypted chunks.\n\n### File Decryption (stream)\n\n<div class=\"codeBox\">\n\n```javascript\nlet state = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n\nlet result = sodium.crypto_secretstream_xchacha20poly1305_pull(\n  state,\n  new Uint8Array(chunk)\n);\n\nif (result) {\n  let decryptedChunk = result.message;\n  stream.enqueue(decryptedChunk);\n\n  if (!last) {\n    // continue decryption\n  }\n}\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_pull()` function initializes a state given a secret `key` and a `header`. The key is derived from the password provided during the decryption, and the header sliced from the file. The key will not be required any more for subsequent operations.\n\n<br>\n\nThe `crypto_secretstream_xchacha20poly1305_pull()` function verifies that the `chunk` contains a valid ciphertext and authentication tag for the given `state`.\n\nThis function will stay in a loop, until a message with the `crypto_secretstream_xchacha20poly1305_TAG_FINAL` tag is found.\n\nIf the decryption key is incorrect the function returns an error.\n\nIf the ciphertext or the authentication tag appear to be invalid it returns an error.\n\n<br>\n\n### Random password generation\n\n<div class=\"codeBox\">\n\n```javascript\nlet password = sodium.to_base64(\n  sodium.randombytes_buf(16),\n  sodium.base64_variants.URLSAFE_NO_PADDING\n);\nreturn password;\n```\n\n</div>\n\nThe `randombytes_buf()` function fills 128 bits starting at buf with an unpredictable sequence of bytes.\n\nThe `to_base64()` function encodes buf as a Base64 string without padding.\n\n<br>\n\n### Keys generation and exchange\n\n<div class=\"codeBox\">\n\n```javascript\nconst keyPair = sodium.crypto_kx_keypair();\nlet keys = {\n  publicKey: sodium.to_base64(keyPair.publicKey),\n  privateKey: sodium.to_base64(keyPair.privateKey),\n};\nreturn keys;\n```\n</div>\n\nThe `crypto_kx_keypair()` function randomly generates a secret key and a corresponding public key. The public key is put into publicKey and the secret key into privateKey. both of 256 bits.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet key = sodium.crypto_kx_client_session_keys(\n  sodium.crypto_scalarmult_base(privateKey),\n  privateKey,\n  publicKey\n);\n```\n</div>\n\nUsing the key exchange API, two parties can securely compute a set of shared keys using their peer's public key and their own secret key.\n\nThe `crypto_kx_client_session_keys()` function computes a pair of 256 bits long shared keys using the recipient's public key, the sender's private key.\n\nThe `crypto_scalarmult_base()` function used to compute the sender's public key from their private key.\n\n<br>\n\n### XChaCha20-Poly1305\n\nXChaCha20 is a variant of ChaCha20 with an extended nonce, allowing random nonces to be safe.\n\nXChaCha20 doesn't require any lookup tables and avoids the possibility of timing attacks.\n\nInternally, XChaCha20 works like a block cipher used in counter mode. It uses the HChaCha20 hash function to derive a subkey and a subnonce from the original key and extended nonce, and a dedicated 64-bit block counter to avoid incrementing the nonce after each block.\n\n<br>\n\n### V2 vs V1\n\n- switching to xchacha20poly1305 for symmetric stream encryption and Argon2id for password-based key derivation. instead of AES-256-GCM and PBKDF2.\n- using the libsodium library for all cryptography instead of the WebCryptoApi.\n- in this version, the app doesn't read the whole file in memory. instead, it's sliced into 64MB chunks that are processed one by one.\n- since we are not using any server-side processing, the app registers a fake download URL (/file) that is going to be handled by the service-worker fetch api.\n- if all validations are passed, a new stream is initialized. then, file chunks are transferred from the main app to the\n  service-worker file via messages.\n- each chunk is encrypted/decrypted on it's own and added to the stream.\n- after each chunk is written on disk it is going to be immediately garbage collected by the browser, this leads to never having more than a few chunks in the memory at the same time.\n\n<br>\n\n[//]: # \"links\"\n[xchacha20-poly1305]: https://libsodium.gitbook.io/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction\n[argon2id]: https://github.com/p-h-c/phc-winner-argon2\n[x25519]: https://cr.yp.to/ecdh.html\n[opensource]: https://github.com/sh-dv/hat.sh\n[bitwarden]: https://bitwarden.com/\n[extending the salsa20 nonce paper]: https://cr.yp.to/snuffle/xsalsa-20081128.pdf\n[soon]: https://tools.ietf.org/html/draft-irtf-cfrg-xchacha\n[github]: https://github.com/sh-dv/hat.sh\n[veracrypt]: https://veracrypt.fr\n[cryptomator]: https://cryptomator.org\n[kryptor]: https://github.com/samuel-lucas6/Kryptor\n[gpg]: https://gnupg.org\n[docker hub]: https://hub.docker.com/r/shdv/hat.sh\n"},{"lang":"es_ES","content":"# [Introduction](#introduction)\n\n---\n\nHat.sh is a free [opensource] web app that provides secure file encryption in the browser.\n\n<br>\n\n# [Features](#features)\n\n---\n\n### Security\n\n- [XChaCha20-Poly1305] - for symmetric encryption.\n- [Argon2id] - for password-based key derivation.\n- [X25519] - for key exchange.\n\nThe libsodium library is used for all cryptographic algorithms. [Technical details here](#technical-details).\n\n<br>\n\n### Privacy\n\n- The app runs locally in your browser.\n- No data is ever collected or sent to anyone.​\n\n<br>\n\n### Functionality\n\n- Secure encryption/decryption of files with passwords or keys.\n- Secure random password generation.\n- Asymmetric key pair generation.\n- Authenticated key exchange.\n- Password strength estimation.\n\n<br>\n\n# [Installation](#installation)\n\n---\nIt's easy to self host and deploy hat.sh, you can do that either with npm or docker\n\nIf you wish to self host the app please follow these instructions:\n\n<br>\n\n## With npm\n\nBefore installation make sure you are running [nodejs](https://nodejs.org/en/) and have [npm](https://www.npmjs.com/) installed\n\n<br >\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. install dependencies\n\n```bash\nnpm install\n```\n\n4. build app\n\n```bash\nnpm run build\n```\n\n5. start hat.sh\n\n```bash\nnpm run start\n```\n\nthe app should be running on port 3391.\n<br>\n\nif you wish to run the app in development enviroment run :\n\n<br>\n\n```bash\nnpm run dev\n```\n\n<br>\n\n## With docker\n\nYou can install the app with docker in multiple ways. You are free to choose which method you like.\n\n<br>\n\n- #### install from docker hub\n\n1. pull image from docker hub\n\n```bash\ndocker pull shdv/hat.sh:latest\n```\n\n2. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Build an image from source\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker\n\n```bash\ndocker build . -t shdv/hat.sh\n```\n\n4. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Using docker compose\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker compose\n\n```bash\ndocker compose build\n```\n\n4. run container\n\n```bash\ndocker compose up\n```\n\n<br>\n\nThe app should be running on port 3991.\n\nhat.sh is also available as a Docker image. You can find it on [Docker Hub].\n\n<br>\n\n\n# [Usage](#usage)\n\n---\n\n## File Encryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Enter a password or generate one.\n5. Download the encrypted file.\n\n> You should always use a strong password!\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Choose public key method.\n5. Enter or load recipient's public key and your private key.\n   if you don't have public and private keys you can generate a key pair.\n6. Download the encrypted file.\n7. Share your public key with the recipient so he will be able to decrypt the file.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n## File Decryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter the encryption password.\n5. Download the decrypted file.\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter or load sender's public key and your private key.\n5. Download the decrypted file.\n\n<br>\n\n# [Limitations](#limitations)\n\n---\n\n### File Signature\n\nFiles encrypted with hat.sh are identifiable by looking at the file signature that is used by the app to verify the content of a file, Such signatures are also known as magic numbers or Magic Bytes. These Bytes are authenticated and cannot be changed.\n\n### Safari and Mobile Browsers\n\nSafari and Mobile browsers are limited to a single file with maximum size of 1GB due to some issues related to service-workers. In addition, this limitation also applies when the app fails to register the service-worker (e.g FireFox Private Browsing).\n\n<br>\n\n# [Best Practices](#best-practices)\n\n---\n\n### Choosing Passwords\n\nThe majority of individuals struggle to create and remember passwords, resulting in weak passwords and password reuse. Password-based encryption is substantially less safe as a result of these improper practices. That's why it is recommended to use the built in password generator and use a password manager like [Bitwarden], where you are able to store the safe password.\n\n\nIf you want to choose a password that you are able to memorize then you should type a passphrase made of 8 words or more.\n\n<br>\n\n### Using public key encryption instead of a password\n\nIf you are encrypting a file that you are going to share it with someone else then you probably should encrypt it with the recipient public key and your private key.\n\n<br>\n\n### Sharing Encrypted Files\n\nIf you plan on sending someone an encrypted file, it is recommended to use your private key and their public key to encrypt the file.\n\nThe file can be shared in any safe file sharing app.\n\n<br>\n\n### Sharing the public key\n\nPublic keys are allowed to be shared, they can be sent as `.public` file or as text.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n### Storing the Public & Private keys\n\nMake sure to store your encryption keys in a safe place and make a backup to an external storage.\n\nStoring your private key in cloud storage is not recommended!\n\n<br>\n\n### Sharing Decryption Passwords\n\nSharing decryption password can be done using a safe end-to-end encrypted messaging app. It's recommended to use a _Disappearing Messages_ feature, and to delete the password after the recipient has decrypted the file.\n\n> Never choose the same password for different files.\n\n<br>\n\n# [FAQ](#faq)\n\n---\n\n### Does the app log or store any of my data?\n\nNo, hat.sh never stores any of your data. It only runs locally in your browser.\n\n<hr style=\"height: 1px\">\n\n### Is hat.sh free?\n\nYes, Hat.sh is free and always will be. However, please consider [donating](https://github.com/sh-dv/hat.sh#donations) to support the project.\n\n<hr style=\"height: 1px\">\n\n### Which file types are supported? Is there a file size limit?\n\nHat.sh accepts all file types. There's no file size limit, meaning files of any size can be encrypted.\n\nSafari browser and mobile/smartphones browsers are limited to 1GB.\n\n<hr style=\"height: 1px\">\n\n### I forgot my password, can I still decrypt my files?\n\nNo, we don't know your password. Always make sure to store your passwords in a password manager.\n\n<hr style=\"height: 1px\">\n\n### Why am I seeing a notice that says \"You have limited experience (single file, 1GB)\"?\n\nIt means that your browser doesn't support the server-worker fetch api. Hence, you are limited to small size files. see [Limitations](#limitations) for more info.\n\n<hr style=\"height: 1px\" id=\"why-need-private-key\">\n\n### Is it safe to share my public key?\n\nYes. Public keys are allowed to be shared, they can be sent as `.public` file or as text.\n\nBut make sure to never share your private key with anyone!\n\n<hr style=\"height: 1px\">\n\n### Why the app asks for my private key in the public key encryption mode?\n\nHat.sh uses authenticated encryption. The sender must provide their private key, a new shared key will be computed from both keys to encrypt the file. Recipient has to provide their private key when decrypting also. this way can verify that the encrypted file was not tampered with, and was sent from the real sender.\n\n<hr style=\"height: 1px\">\n\n### I have lost my private key, is it possible to recover it?\n\nNope. lost private keys cannot be recovered.\n\nAlso, if you feel that your private key has been compromised (e.g accidentally shared / computer hacked) then you must decrypt all files that were encrypted with that key, generate a new keypair and re-encrypt the files.\n\n<hr style=\"height: 1px\">\n\n### How do I generate a keypair (Public & Private)?\n\nYou can generate keys by visit the [key generate page](https://hat.sh/generate-keys), make sure to [store the keys safely](#best-practices).\n\n<hr style=\"height: 1px\">\n\n### Does the app measure password strength?\n\nWe use [zxcvbn](https://github.com/dropbox/zxcvbn) JS implementation to check the entropy of the password input, this entropy will be converted to score that will be displayed on screen.\n\n<hr style=\"height: 1px\">\n\n### Does the app connect to the internet?\n\nOnce you visit the site and the page loads, it runs only offline.\n\n<hr style=\"height: 1px\">\n\n### How can I contribute?\n\nHat.sh is an open-source application. You can help make it better by making commits on GitHub. The project is maintained in my free time. [Donations](https://github.com/sh-dv/hat.sh#donations) of any size are appreciated.\n\n<hr style=\"height: 1px\">\n\n### How do I report bugs?\n\nPlease report bugs via [Github] by opening an issue labeled with \"bug\".\n\n<hr style=\"height: 1px\">\n\n### How do I report a security vulnerability?\n\nIf you identify a valid security issue, please write an email to hatsh-security@pm.me\n\nThere is no bounty available at the moment, but your github account will be credited in the acknowledgements section in the app documentation.\n\n<hr style=\"height: 1px\">\n\n### Why should I use hat.sh?\n\n1. The app uses fast modern secure cryptographic algorithms.\n2. It's super fast and easy to use.\n3. It runs in the browser, no need to setup or install anything.\n4. It's free opensource software and can be easily self hosted.\n\n<hr style=\"height: 1px\">\n\n### When should I not use hat.sh?\n\n1. If you want to encrypt a disk (e.g [VeraCrypt]).\n2. If you want to frequently access encrypted files (e.g [Cryptomator]).\n3. If you want to encrypt and sign files in the same tool. (e.g [Kryptor]).\n4. If you prefer a command line tool (e.g [Kryptor]).\n5. If you want something that adheres to industry standards, use [GPG].\n\n<br>\n\n# [Technical Details](#technical-details)\n\n---\n\n### Password hashing and Key derivation\n\nPassword hashing functions derive a secret key of any size from a password and a salt.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet salt = sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);\nlet key = sodium.crypto_pwhash(\n  sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES,\n  password,\n  salt,\n  sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_ALG_ARGON2ID13\n);\n```\n\n</div>\n\nThe `crypto_pwhash()` function derives an 256 bits long key from a password and a salt salt whose fixed length is 128 bits, which should be unpredictable.\n\n`randombytes_buf()` is the easiest way to fill the 128 bits of the salt.\n\n<br>\n\n`OPSLIMIT` represents a maximum amount of computations to perform.\n\n`MEMLIMIT` is the maximum amount of RAM that the function will use, in bytes.\n\n<br>\n\n`crypto_pwhash_OPSLIMIT_INTERACTIVE` and `crypto_pwhash_MEMLIMIT_INTERACTIVE` provide base line for these two parameters. This currently requires 64 MiB of dedicated RAM. which is suitable for in-browser operations.\n<br>\n`crypto_pwhash_ALG_ARGON2ID13` using the Argon2id algorithm version 1.3.\n\n<br>\n\n### File Encryption (stream)\n\nIn order to use the app to encrypt a file, the user has to provide a valid file and a password. this password gets hashed and a secure key is derived from it with Argon2id to encrypt the file.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet res = sodium.crypto_secretstream_xchacha20poly1305_init_push(key);\nheader = res.header;\nstate = res.state;\n\nlet tag = last\n  ? sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL\n  : sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;\n\nlet encryptedChunk = sodium.crypto_secretstream_xchacha20poly1305_push(\n  state,\n  new Uint8Array(chunk),\n  null,\n  tag\n);\n\nstream.enqueue(signature, salt, header, encryptedChunk);\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_push` function creates an encrypted stream where it initializes a `state` using the key and an internal, automatically generated initialization vector. It then stores the stream header into `header` that has a size of 192 bits.\n\nThis is the first function to call in order to create an encrypted stream. The key will not be required any more for subsequent operations.\n\n<br>\n\nAn encrypted stream starts with a short header, whose size is 192 bits. That header must be sent/stored before the sequence of encrypted messages, as it is required to decrypt the stream. The header content doesn't have to be secret because decryption with a different header would fail.\n\nA tag is attached to each message accoring to the value of `last`, which indicates if that is the last chunk of the file or not. That tag can be any of:\n\n1. `crypto_secretstream_xchacha20poly1305_TAG_MESSAGE`: This doesn't add any information about the nature of the message.\n2. `crypto_secretstream_xchacha20poly1305_TAG_FINAL`: This indicates that the message marks the end of the stream, and erases the secret key used to encrypt the previous sequence.\n\nThe `crypto_secretstream_xchacha20poly1305_push()` function encrypts the file `chunk` using the `state` and the `tag`, without any additional information (`null`).\n<br>\n\nthe XChaCha20 stream cipher Poly1305 MAC authentication are used for encryption.\n\n`stream.enqueue()` function adds the hat.sh signature(magic bytes), salt and header followed by the encrypted chunks.\n\n### File Decryption (stream)\n\n<div class=\"codeBox\">\n\n```javascript\nlet state = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n\nlet result = sodium.crypto_secretstream_xchacha20poly1305_pull(\n  state,\n  new Uint8Array(chunk)\n);\n\nif (result) {\n  let decryptedChunk = result.message;\n  stream.enqueue(decryptedChunk);\n\n  if (!last) {\n    // continue decryption\n  }\n}\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_pull()` function initializes a state given a secret `key` and a `header`. The key is derived from the password provided during the decryption, and the header sliced from the file. The key will not be required any more for subsequent operations.\n\n<br>\n\nThe `crypto_secretstream_xchacha20poly1305_pull()` function verifies that the `chunk` contains a valid ciphertext and authentication tag for the given `state`.\n\nThis function will stay in a loop, until a message with the `crypto_secretstream_xchacha20poly1305_TAG_FINAL` tag is found.\n\nIf the decryption key is incorrect the function returns an error.\n\nIf the ciphertext or the authentication tag appear to be invalid it returns an error.\n\n<br>\n\n### Random password generation\n\n<div class=\"codeBox\">\n\n```javascript\nlet password = sodium.to_base64(\n  sodium.randombytes_buf(16),\n  sodium.base64_variants.URLSAFE_NO_PADDING\n);\nreturn password;\n```\n\n</div>\n\nThe `randombytes_buf()` function fills 128 bits starting at buf with an unpredictable sequence of bytes.\n\nThe `to_base64()` function encodes buf as a Base64 string without padding.\n\n<br>\n\n### Keys generation and exchange\n\n<div class=\"codeBox\">\n\n```javascript\nconst keyPair = sodium.crypto_kx_keypair();\nlet keys = {\n  publicKey: sodium.to_base64(keyPair.publicKey),\n  privateKey: sodium.to_base64(keyPair.privateKey),\n};\nreturn keys;\n```\n</div>\n\nThe `crypto_kx_keypair()` function randomly generates a secret key and a corresponding public key. The public key is put into publicKey and the secret key into privateKey. both of 256 bits.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet key = sodium.crypto_kx_client_session_keys(\n  sodium.crypto_scalarmult_base(privateKey),\n  privateKey,\n  publicKey\n);\n```\n</div>\n\nUsing the key exchange API, two parties can securely compute a set of shared keys using their peer's public key and their own secret key.\n\nThe `crypto_kx_client_session_keys()` function computes a pair of 256 bits long shared keys using the recipient's public key, the sender's private key.\n\nThe `crypto_scalarmult_base()` function used to compute the sender's public key from their private key.\n\n<br>\n\n### XChaCha20-Poly1305\n\nXChaCha20 is a variant of ChaCha20 with an extended nonce, allowing random nonces to be safe.\n\nXChaCha20 doesn't require any lookup tables and avoids the possibility of timing attacks.\n\nInternally, XChaCha20 works like a block cipher used in counter mode. It uses the HChaCha20 hash function to derive a subkey and a subnonce from the original key and extended nonce, and a dedicated 64-bit block counter to avoid incrementing the nonce after each block.\n\n<br>\n\n### V2 vs V1\n\n- switching to xchacha20poly1305 for symmetric stream encryption and Argon2id for password-based key derivation. instead of AES-256-GCM and PBKDF2.\n- using the libsodium library for all cryptography instead of the WebCryptoApi.\n- in this version, the app doesn't read the whole file in memory. instead, it's sliced into 64MB chunks that are processed one by one.\n- since we are not using any server-side processing, the app registers a fake download URL (/file) that is going to be handled by the service-worker fetch api.\n- if all validations are passed, a new stream is initialized. then, file chunks are transferred from the main app to the\n  service-worker file via messages.\n- each chunk is encrypted/decrypted on it's own and added to the stream.\n- after each chunk is written on disk it is going to be immediately garbage collected by the browser, this leads to never having more than a few chunks in the memory at the same time.\n\n<br>\n\n[//]: # \"links\"\n[xchacha20-poly1305]: https://libsodium.gitbook.io/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction\n[argon2id]: https://github.com/p-h-c/phc-winner-argon2\n[x25519]: https://cr.yp.to/ecdh.html\n[opensource]: https://github.com/sh-dv/hat.sh\n[bitwarden]: https://bitwarden.com/\n[extending the salsa20 nonce paper]: https://cr.yp.to/snuffle/xsalsa-20081128.pdf\n[soon]: https://tools.ietf.org/html/draft-irtf-cfrg-xchacha\n[github]: https://github.com/sh-dv/hat.sh\n[veracrypt]: https://veracrypt.fr\n[cryptomator]: https://cryptomator.org\n[kryptor]: https://github.com/samuel-lucas6/Kryptor\n[gpg]: https://gnupg.org\n[docker hub]: https://hub.docker.com/r/shdv/hat.sh\n"},{"lang":"cs_CS","content":"# [Introduction](#introduction)\n\n---\n\nHat.sh is a free [opensource] web app that provides secure file encryption in the browser.\n\n<br>\n\n# [Features](#features)\n\n---\n\n### Security\n\n- [XChaCha20-Poly1305] - for symmetric encryption.\n- [Argon2id] - for password-based key derivation.\n- [X25519] - for key exchange.\n\nThe libsodium library is used for all cryptographic algorithms. [Technical details here](#technical-details).\n\n<br>\n\n### Privacy\n\n- The app runs locally in your browser.\n- No data is ever collected or sent to anyone.​\n\n<br>\n\n### Functionality\n\n- Secure encryption/decryption of files with passwords or keys.\n- Secure random password generation.\n- Asymmetric key pair generation.\n- Authenticated key exchange.\n- Password strength estimation.\n\n<br>\n\n# [Installation](#installation)\n\n---\nIt's easy to self host and deploy hat.sh, you can do that either with npm or docker\n\nIf you wish to self host the app please follow these instructions:\n\n<br>\n\n## With npm\n\nBefore installation make sure you are running [nodejs](https://nodejs.org/en/) and have [npm](https://www.npmjs.com/) installed\n\n<br >\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. install dependencies\n\n```bash\nnpm install\n```\n\n4. build app\n\n```bash\nnpm run build\n```\n\n5. start hat.sh\n\n```bash\nnpm run start\n```\n\nthe app should be running on port 3391.\n<br>\n\nif you wish to run the app in development enviroment run :\n\n<br>\n\n```bash\nnpm run dev\n```\n\n<br>\n\n## With docker\n\nYou can install the app with docker in multiple ways. You are free to choose which method you like.\n\n<br>\n\n- #### install from docker hub\n\n1. pull image from docker hub\n\n```bash\ndocker pull shdv/hat.sh:latest\n```\n\n2. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Build an image from source\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker\n\n```bash\ndocker build . -t shdv/hat.sh\n```\n\n4. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Using docker compose\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker compose\n\n```bash\ndocker compose build\n```\n\n4. run container\n\n```bash\ndocker compose up\n```\n\n<br>\n\nThe app should be running on port 3991.\n\nhat.sh is also available as a Docker image. You can find it on [Docker Hub].\n\n<br>\n\n\n# [Usage](#usage)\n\n---\n\n## File Encryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Enter a password or generate one.\n5. Download the encrypted file.\n\n> You should always use a strong password!\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Choose public key method.\n5. Enter or load recipient's public key and your private key.\n   if you don't have public and private keys you can generate a key pair.\n6. Download the encrypted file.\n7. Share your public key with the recipient so he will be able to decrypt the file.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n## File Decryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter the encryption password.\n5. Download the decrypted file.\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter or load sender's public key and your private key.\n5. Download the decrypted file.\n\n<br>\n\n# [Limitations](#limitations)\n\n---\n\n### File Signature\n\nFiles encrypted with hat.sh are identifiable by looking at the file signature that is used by the app to verify the content of a file, Such signatures are also known as magic numbers or Magic Bytes. These Bytes are authenticated and cannot be changed.\n\n### Safari and Mobile Browsers\n\nSafari and Mobile browsers are limited to a single file with maximum size of 1GB due to some issues related to service-workers. In addition, this limitation also applies when the app fails to register the service-worker (e.g FireFox Private Browsing).\n\n<br>\n\n# [Best Practices](#best-practices)\n\n---\n\n### Choosing Passwords\n\nThe majority of individuals struggle to create and remember passwords, resulting in weak passwords and password reuse. Password-based encryption is substantially less safe as a result of these improper practices. That's why it is recommended to use the built in password generator and use a password manager like [Bitwarden], where you are able to store the safe password.\n\n\nIf you want to choose a password that you are able to memorize then you should type a passphrase made of 8 words or more.\n\n<br>\n\n### Using public key encryption instead of a password\n\nIf you are encrypting a file that you are going to share it with someone else then you probably should encrypt it with the recipient public key and your private key.\n\n<br>\n\n### Sharing Encrypted Files\n\nIf you plan on sending someone an encrypted file, it is recommended to use your private key and their public key to encrypt the file.\n\nThe file can be shared in any safe file sharing app.\n\n<br>\n\n### Sharing the public key\n\nPublic keys are allowed to be shared, they can be sent as `.public` file or as text.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n### Storing the Public & Private keys\n\nMake sure to store your encryption keys in a safe place and make a backup to an external storage.\n\nStoring your private key in cloud storage is not recommended!\n\n<br>\n\n### Sharing Decryption Passwords\n\nSharing decryption password can be done using a safe end-to-end encrypted messaging app. It's recommended to use a _Disappearing Messages_ feature, and to delete the password after the recipient has decrypted the file.\n\n> Never choose the same password for different files.\n\n<br>\n\n# [FAQ](#faq)\n\n---\n\n### Does the app log or store any of my data?\n\nNo, hat.sh never stores any of your data. It only runs locally in your browser.\n\n<hr style=\"height: 1px\">\n\n### Is hat.sh free?\n\nYes, Hat.sh is free and always will be. However, please consider [donating](https://github.com/sh-dv/hat.sh#donations) to support the project.\n\n<hr style=\"height: 1px\">\n\n### Which file types are supported? Is there a file size limit?\n\nHat.sh accepts all file types. There's no file size limit, meaning files of any size can be encrypted.\n\nSafari browser and mobile/smartphones browsers are limited to 1GB.\n\n<hr style=\"height: 1px\">\n\n### I forgot my password, can I still decrypt my files?\n\nNo, we don't know your password. Always make sure to store your passwords in a password manager.\n\n<hr style=\"height: 1px\">\n\n### Why am I seeing a notice that says \"You have limited experience (single file, 1GB)\"?\n\nIt means that your browser doesn't support the server-worker fetch api. Hence, you are limited to small size files. see [Limitations](#limitations) for more info.\n\n<hr style=\"height: 1px\" id=\"why-need-private-key\">\n\n### Is it safe to share my public key?\n\nYes. Public keys are allowed to be shared, they can be sent as `.public` file or as text.\n\nBut make sure to never share your private key with anyone!\n\n<hr style=\"height: 1px\">\n\n### Why the app asks for my private key in the public key encryption mode?\n\nHat.sh uses authenticated encryption. The sender must provide their private key, a new shared key will be computed from both keys to encrypt the file. Recipient has to provide their private key when decrypting also. this way can verify that the encrypted file was not tampered with, and was sent from the real sender.\n\n<hr style=\"height: 1px\">\n\n### I have lost my private key, is it possible to recover it?\n\nNope. lost private keys cannot be recovered.\n\nAlso, if you feel that your private key has been compromised (e.g accidentally shared / computer hacked) then you must decrypt all files that were encrypted with that key, generate a new keypair and re-encrypt the files.\n\n<hr style=\"height: 1px\">\n\n### How do I generate a keypair (Public & Private)?\n\nYou can generate keys by visit the [key generate page](https://hat.sh/generate-keys), make sure to [store the keys safely](#best-practices).\n\n<hr style=\"height: 1px\">\n\n### Does the app measure password strength?\n\nWe use [zxcvbn](https://github.com/dropbox/zxcvbn) JS implementation to check the entropy of the password input, this entropy will be converted to score that will be displayed on screen.\n\n<hr style=\"height: 1px\">\n\n### Does the app connect to the internet?\n\nOnce you visit the site and the page loads, it runs only offline.\n\n<hr style=\"height: 1px\">\n\n### How can I contribute?\n\nHat.sh is an open-source application. You can help make it better by making commits on GitHub. The project is maintained in my free time. [Donations](https://github.com/sh-dv/hat.sh#donations) of any size are appreciated.\n\n<hr style=\"height: 1px\">\n\n### How do I report bugs?\n\nPlease report bugs via [Github] by opening an issue labeled with \"bug\".\n\n<hr style=\"height: 1px\">\n\n### How do I report a security vulnerability?\n\nIf you identify a valid security issue, please write an email to hatsh-security@pm.me\n\nThere is no bounty available at the moment, but your github account will be credited in the acknowledgements section in the app documentation.\n\n<hr style=\"height: 1px\">\n\n### Why should I use hat.sh?\n\n1. The app uses fast modern secure cryptographic algorithms.\n2. It's super fast and easy to use.\n3. It runs in the browser, no need to setup or install anything.\n4. It's free opensource software and can be easily self hosted.\n\n<hr style=\"height: 1px\">\n\n### When should I not use hat.sh?\n\n1. If you want to encrypt a disk (e.g [VeraCrypt]).\n2. If you want to frequently access encrypted files (e.g [Cryptomator]).\n3. If you want to encrypt and sign files in the same tool. (e.g [Kryptor]).\n4. If you prefer a command line tool (e.g [Kryptor]).\n5. If you want something that adheres to industry standards, use [GPG].\n\n<br>\n\n# [Technical Details](#technical-details)\n\n---\n\n### Password hashing and Key derivation\n\nPassword hashing functions derive a secret key of any size from a password and a salt.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet salt = sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);\nlet key = sodium.crypto_pwhash(\n  sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES,\n  password,\n  salt,\n  sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_ALG_ARGON2ID13\n);\n```\n\n</div>\n\nThe `crypto_pwhash()` function derives an 256 bits long key from a password and a salt salt whose fixed length is 128 bits, which should be unpredictable.\n\n`randombytes_buf()` is the easiest way to fill the 128 bits of the salt.\n\n<br>\n\n`OPSLIMIT` represents a maximum amount of computations to perform.\n\n`MEMLIMIT` is the maximum amount of RAM that the function will use, in bytes.\n\n<br>\n\n`crypto_pwhash_OPSLIMIT_INTERACTIVE` and `crypto_pwhash_MEMLIMIT_INTERACTIVE` provide base line for these two parameters. This currently requires 64 MiB of dedicated RAM. which is suitable for in-browser operations.\n<br>\n`crypto_pwhash_ALG_ARGON2ID13` using the Argon2id algorithm version 1.3.\n\n<br>\n\n### File Encryption (stream)\n\nIn order to use the app to encrypt a file, the user has to provide a valid file and a password. this password gets hashed and a secure key is derived from it with Argon2id to encrypt the file.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet res = sodium.crypto_secretstream_xchacha20poly1305_init_push(key);\nheader = res.header;\nstate = res.state;\n\nlet tag = last\n  ? sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL\n  : sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;\n\nlet encryptedChunk = sodium.crypto_secretstream_xchacha20poly1305_push(\n  state,\n  new Uint8Array(chunk),\n  null,\n  tag\n);\n\nstream.enqueue(signature, salt, header, encryptedChunk);\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_push` function creates an encrypted stream where it initializes a `state` using the key and an internal, automatically generated initialization vector. It then stores the stream header into `header` that has a size of 192 bits.\n\nThis is the first function to call in order to create an encrypted stream. The key will not be required any more for subsequent operations.\n\n<br>\n\nAn encrypted stream starts with a short header, whose size is 192 bits. That header must be sent/stored before the sequence of encrypted messages, as it is required to decrypt the stream. The header content doesn't have to be secret because decryption with a different header would fail.\n\nA tag is attached to each message accoring to the value of `last`, which indicates if that is the last chunk of the file or not. That tag can be any of:\n\n1. `crypto_secretstream_xchacha20poly1305_TAG_MESSAGE`: This doesn't add any information about the nature of the message.\n2. `crypto_secretstream_xchacha20poly1305_TAG_FINAL`: This indicates that the message marks the end of the stream, and erases the secret key used to encrypt the previous sequence.\n\nThe `crypto_secretstream_xchacha20poly1305_push()` function encrypts the file `chunk` using the `state` and the `tag`, without any additional information (`null`).\n<br>\n\nthe XChaCha20 stream cipher Poly1305 MAC authentication are used for encryption.\n\n`stream.enqueue()` function adds the hat.sh signature(magic bytes), salt and header followed by the encrypted chunks.\n\n### File Decryption (stream)\n\n<div class=\"codeBox\">\n\n```javascript\nlet state = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n\nlet result = sodium.crypto_secretstream_xchacha20poly1305_pull(\n  state,\n  new Uint8Array(chunk)\n);\n\nif (result) {\n  let decryptedChunk = result.message;\n  stream.enqueue(decryptedChunk);\n\n  if (!last) {\n    // continue decryption\n  }\n}\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_pull()` function initializes a state given a secret `key` and a `header`. The key is derived from the password provided during the decryption, and the header sliced from the file. The key will not be required any more for subsequent operations.\n\n<br>\n\nThe `crypto_secretstream_xchacha20poly1305_pull()` function verifies that the `chunk` contains a valid ciphertext and authentication tag for the given `state`.\n\nThis function will stay in a loop, until a message with the `crypto_secretstream_xchacha20poly1305_TAG_FINAL` tag is found.\n\nIf the decryption key is incorrect the function returns an error.\n\nIf the ciphertext or the authentication tag appear to be invalid it returns an error.\n\n<br>\n\n### Random password generation\n\n<div class=\"codeBox\">\n\n```javascript\nlet password = sodium.to_base64(\n  sodium.randombytes_buf(16),\n  sodium.base64_variants.URLSAFE_NO_PADDING\n);\nreturn password;\n```\n\n</div>\n\nThe `randombytes_buf()` function fills 128 bits starting at buf with an unpredictable sequence of bytes.\n\nThe `to_base64()` function encodes buf as a Base64 string without padding.\n\n<br>\n\n### Keys generation and exchange\n\n<div class=\"codeBox\">\n\n```javascript\nconst keyPair = sodium.crypto_kx_keypair();\nlet keys = {\n  publicKey: sodium.to_base64(keyPair.publicKey),\n  privateKey: sodium.to_base64(keyPair.privateKey),\n};\nreturn keys;\n```\n</div>\n\nThe `crypto_kx_keypair()` function randomly generates a secret key and a corresponding public key. The public key is put into publicKey and the secret key into privateKey. both of 256 bits.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet key = sodium.crypto_kx_client_session_keys(\n  sodium.crypto_scalarmult_base(privateKey),\n  privateKey,\n  publicKey\n);\n```\n</div>\n\nUsing the key exchange API, two parties can securely compute a set of shared keys using their peer's public key and their own secret key.\n\nThe `crypto_kx_client_session_keys()` function computes a pair of 256 bits long shared keys using the recipient's public key, the sender's private key.\n\nThe `crypto_scalarmult_base()` function used to compute the sender's public key from their private key.\n\n<br>\n\n### XChaCha20-Poly1305\n\nXChaCha20 is a variant of ChaCha20 with an extended nonce, allowing random nonces to be safe.\n\nXChaCha20 doesn't require any lookup tables and avoids the possibility of timing attacks.\n\nInternally, XChaCha20 works like a block cipher used in counter mode. It uses the HChaCha20 hash function to derive a subkey and a subnonce from the original key and extended nonce, and a dedicated 64-bit block counter to avoid incrementing the nonce after each block.\n\n<br>\n\n### V2 vs V1\n\n- switching to xchacha20poly1305 for symmetric stream encryption and Argon2id for password-based key derivation. instead of AES-256-GCM and PBKDF2.\n- using the libsodium library for all cryptography instead of the WebCryptoApi.\n- in this version, the app doesn't read the whole file in memory. instead, it's sliced into 64MB chunks that are processed one by one.\n- since we are not using any server-side processing, the app registers a fake download URL (/file) that is going to be handled by the service-worker fetch api.\n- if all validations are passed, a new stream is initialized. then, file chunks are transferred from the main app to the\n  service-worker file via messages.\n- each chunk is encrypted/decrypted on it's own and added to the stream.\n- after each chunk is written on disk it is going to be immediately garbage collected by the browser, this leads to never having more than a few chunks in the memory at the same time.\n\n<br>\n\n[//]: # \"links\"\n[xchacha20-poly1305]: https://libsodium.gitbook.io/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction\n[argon2id]: https://github.com/p-h-c/phc-winner-argon2\n[x25519]: https://cr.yp.to/ecdh.html\n[opensource]: https://github.com/sh-dv/hat.sh\n[bitwarden]: https://bitwarden.com/\n[extending the salsa20 nonce paper]: https://cr.yp.to/snuffle/xsalsa-20081128.pdf\n[soon]: https://tools.ietf.org/html/draft-irtf-cfrg-xchacha\n[github]: https://github.com/sh-dv/hat.sh\n[veracrypt]: https://veracrypt.fr\n[cryptomator]: https://cryptomator.org\n[kryptor]: https://github.com/samuel-lucas6/Kryptor\n[gpg]: https://gnupg.org\n[docker hub]: https://hub.docker.com/r/shdv/hat.sh\n"},{"lang":"tr_TR","content":"# [Introduction](#introduction)\n\n---\n\nHat.sh is a free [opensource] web app that provides secure file encryption in the browser.\n\n<br>\n\n# [Features](#features)\n\n---\n\n### Security\n\n- [XChaCha20-Poly1305] - for symmetric encryption.\n- [Argon2id] - for password-based key derivation.\n- [X25519] - for key exchange.\n\nThe libsodium library is used for all cryptographic algorithms. [Technical details here](#technical-details).\n\n<br>\n\n### Privacy\n\n- The app runs locally in your browser.\n- No data is ever collected or sent to anyone.​\n\n<br>\n\n### Functionality\n\n- Secure encryption/decryption of files with passwords or keys.\n- Secure random password generation.\n- Asymmetric key pair generation.\n- Authenticated key exchange.\n- Password strength estimation.\n\n<br>\n\n# [Installation](#installation)\n\n---\nIt's easy to self host and deploy hat.sh, you can do that either with npm or docker\n\nIf you wish to self host the app please follow these instructions:\n\n<br>\n\n## With npm\n\nBefore installation make sure you are running [nodejs](https://nodejs.org/en/) and have [npm](https://www.npmjs.com/) installed\n\n<br >\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. install dependencies\n\n```bash\nnpm install\n```\n\n4. build app\n\n```bash\nnpm run build\n```\n\n5. start hat.sh\n\n```bash\nnpm run start\n```\n\nthe app should be running on port 3391.\n<br>\n\nif you wish to run the app in development enviroment run :\n\n<br>\n\n```bash\nnpm run dev\n```\n\n<br>\n\n## With docker\n\nYou can install the app with docker in multiple ways. You are free to choose which method you like.\n\n<br>\n\n- #### install from docker hub\n\n1. pull image from docker hub\n\n```bash\ndocker pull shdv/hat.sh:latest\n```\n\n2. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Build an image from source\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker\n\n```bash\ndocker build . -t shdv/hat.sh\n```\n\n4. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Using docker compose\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker compose\n\n```bash\ndocker compose build\n```\n\n4. run container\n\n```bash\ndocker compose up\n```\n\n<br>\n\nThe app should be running on port 3991.\n\nhat.sh is also available as a Docker image. You can find it on [Docker Hub].\n\n<br>\n\n\n# [Usage](#usage)\n\n---\n\n## File Encryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Enter a password or generate one.\n5. Download the encrypted file.\n\n> You should always use a strong password!\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Choose public key method.\n5. Enter or load recipient's public key and your private key.\n   if you don't have public and private keys you can generate a key pair.\n6. Download the encrypted file.\n7. Share your public key with the recipient so he will be able to decrypt the file.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n## File Decryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter the encryption password.\n5. Download the decrypted file.\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter or load sender's public key and your private key.\n5. Download the decrypted file.\n\n<br>\n\n# [Limitations](#limitations)\n\n---\n\n### File Signature\n\nFiles encrypted with hat.sh are identifiable by looking at the file signature that is used by the app to verify the content of a file, Such signatures are also known as magic numbers or Magic Bytes. These Bytes are authenticated and cannot be changed.\n\n### Safari and Mobile Browsers\n\nSafari and Mobile browsers are limited to a single file with maximum size of 1GB due to some issues related to service-workers. In addition, this limitation also applies when the app fails to register the service-worker (e.g FireFox Private Browsing).\n\n<br>\n\n# [Best Practices](#best-practices)\n\n---\n\n### Choosing Passwords\n\nThe majority of individuals struggle to create and remember passwords, resulting in weak passwords and password reuse. Password-based encryption is substantially less safe as a result of these improper practices. That's why it is recommended to use the built in password generator and use a password manager like [Bitwarden], where you are able to store the safe password.\n\n\nIf you want to choose a password that you are able to memorize then you should type a passphrase made of 8 words or more.\n\n<br>\n\n### Using public key encryption instead of a password\n\nIf you are encrypting a file that you are going to share it with someone else then you probably should encrypt it with the recipient public key and your private key.\n\n<br>\n\n### Sharing Encrypted Files\n\nIf you plan on sending someone an encrypted file, it is recommended to use your private key and their public key to encrypt the file.\n\nThe file can be shared in any safe file sharing app.\n\n<br>\n\n### Sharing the public key\n\nPublic keys are allowed to be shared, they can be sent as `.public` file or as text.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n### Storing the Public & Private keys\n\nMake sure to store your encryption keys in a safe place and make a backup to an external storage.\n\nStoring your private key in cloud storage is not recommended!\n\n<br>\n\n### Sharing Decryption Passwords\n\nSharing decryption password can be done using a safe end-to-end encrypted messaging app. It's recommended to use a _Disappearing Messages_ feature, and to delete the password after the recipient has decrypted the file.\n\n> Never choose the same password for different files.\n\n<br>\n\n# [FAQ](#faq)\n\n---\n\n### Does the app log or store any of my data?\n\nNo, hat.sh never stores any of your data. It only runs locally in your browser.\n\n<hr style=\"height: 1px\">\n\n### Is hat.sh free?\n\nYes, Hat.sh is free and always will be. However, please consider [donating](https://github.com/sh-dv/hat.sh#donations) to support the project.\n\n<hr style=\"height: 1px\">\n\n### Which file types are supported? Is there a file size limit?\n\nHat.sh accepts all file types. There's no file size limit, meaning files of any size can be encrypted.\n\nSafari browser and mobile/smartphones browsers are limited to 1GB.\n\n<hr style=\"height: 1px\">\n\n### I forgot my password, can I still decrypt my files?\n\nNo, we don't know your password. Always make sure to store your passwords in a password manager.\n\n<hr style=\"height: 1px\">\n\n### Why am I seeing a notice that says \"You have limited experience (single file, 1GB)\"?\n\nIt means that your browser doesn't support the server-worker fetch api. Hence, you are limited to small size files. see [Limitations](#limitations) for more info.\n\n<hr style=\"height: 1px\" id=\"why-need-private-key\">\n\n### Is it safe to share my public key?\n\nYes. Public keys are allowed to be shared, they can be sent as `.public` file or as text.\n\nBut make sure to never share your private key with anyone!\n\n<hr style=\"height: 1px\">\n\n### Why the app asks for my private key in the public key encryption mode?\n\nHat.sh uses authenticated encryption. The sender must provide their private key, a new shared key will be computed from both keys to encrypt the file. Recipient has to provide their private key when decrypting also. this way can verify that the encrypted file was not tampered with, and was sent from the real sender.\n\n<hr style=\"height: 1px\">\n\n### I have lost my private key, is it possible to recover it?\n\nNope. lost private keys cannot be recovered.\n\nAlso, if you feel that your private key has been compromised (e.g accidentally shared / computer hacked) then you must decrypt all files that were encrypted with that key, generate a new keypair and re-encrypt the files.\n\n<hr style=\"height: 1px\">\n\n### How do I generate a keypair (Public & Private)?\n\nYou can generate keys by visit the [key generate page](https://hat.sh/generate-keys), make sure to [store the keys safely](#best-practices).\n\n<hr style=\"height: 1px\">\n\n### Does the app measure password strength?\n\nWe use [zxcvbn](https://github.com/dropbox/zxcvbn) JS implementation to check the entropy of the password input, this entropy will be converted to score that will be displayed on screen.\n\n<hr style=\"height: 1px\">\n\n### Does the app connect to the internet?\n\nOnce you visit the site and the page loads, it runs only offline.\n\n<hr style=\"height: 1px\">\n\n### How can I contribute?\n\nHat.sh is an open-source application. You can help make it better by making commits on GitHub. The project is maintained in my free time. [Donations](https://github.com/sh-dv/hat.sh#donations) of any size are appreciated.\n\n<hr style=\"height: 1px\">\n\n### How do I report bugs?\n\nPlease report bugs via [Github] by opening an issue labeled with \"bug\".\n\n<hr style=\"height: 1px\">\n\n### How do I report a security vulnerability?\n\nIf you identify a valid security issue, please write an email to hatsh-security@pm.me\n\nThere is no bounty available at the moment, but your github account will be credited in the acknowledgements section in the app documentation.\n\n<hr style=\"height: 1px\">\n\n### Why should I use hat.sh?\n\n1. The app uses fast modern secure cryptographic algorithms.\n2. It's super fast and easy to use.\n3. It runs in the browser, no need to setup or install anything.\n4. It's free opensource software and can be easily self hosted.\n\n<hr style=\"height: 1px\">\n\n### When should I not use hat.sh?\n\n1. If you want to encrypt a disk (e.g [VeraCrypt]).\n2. If you want to frequently access encrypted files (e.g [Cryptomator]).\n3. If you want to encrypt and sign files in the same tool. (e.g [Kryptor]).\n4. If you prefer a command line tool (e.g [Kryptor]).\n5. If you want something that adheres to industry standards, use [GPG].\n\n<br>\n\n# [Technical Details](#technical-details)\n\n---\n\n### Password hashing and Key derivation\n\nPassword hashing functions derive a secret key of any size from a password and a salt.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet salt = sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);\nlet key = sodium.crypto_pwhash(\n  sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES,\n  password,\n  salt,\n  sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_ALG_ARGON2ID13\n);\n```\n\n</div>\n\nThe `crypto_pwhash()` function derives an 256 bits long key from a password and a salt salt whose fixed length is 128 bits, which should be unpredictable.\n\n`randombytes_buf()` is the easiest way to fill the 128 bits of the salt.\n\n<br>\n\n`OPSLIMIT` represents a maximum amount of computations to perform.\n\n`MEMLIMIT` is the maximum amount of RAM that the function will use, in bytes.\n\n<br>\n\n`crypto_pwhash_OPSLIMIT_INTERACTIVE` and `crypto_pwhash_MEMLIMIT_INTERACTIVE` provide base line for these two parameters. This currently requires 64 MiB of dedicated RAM. which is suitable for in-browser operations.\n<br>\n`crypto_pwhash_ALG_ARGON2ID13` using the Argon2id algorithm version 1.3.\n\n<br>\n\n### File Encryption (stream)\n\nIn order to use the app to encrypt a file, the user has to provide a valid file and a password. this password gets hashed and a secure key is derived from it with Argon2id to encrypt the file.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet res = sodium.crypto_secretstream_xchacha20poly1305_init_push(key);\nheader = res.header;\nstate = res.state;\n\nlet tag = last\n  ? sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL\n  : sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;\n\nlet encryptedChunk = sodium.crypto_secretstream_xchacha20poly1305_push(\n  state,\n  new Uint8Array(chunk),\n  null,\n  tag\n);\n\nstream.enqueue(signature, salt, header, encryptedChunk);\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_push` function creates an encrypted stream where it initializes a `state` using the key and an internal, automatically generated initialization vector. It then stores the stream header into `header` that has a size of 192 bits.\n\nThis is the first function to call in order to create an encrypted stream. The key will not be required any more for subsequent operations.\n\n<br>\n\nAn encrypted stream starts with a short header, whose size is 192 bits. That header must be sent/stored before the sequence of encrypted messages, as it is required to decrypt the stream. The header content doesn't have to be secret because decryption with a different header would fail.\n\nA tag is attached to each message accoring to the value of `last`, which indicates if that is the last chunk of the file or not. That tag can be any of:\n\n1. `crypto_secretstream_xchacha20poly1305_TAG_MESSAGE`: This doesn't add any information about the nature of the message.\n2. `crypto_secretstream_xchacha20poly1305_TAG_FINAL`: This indicates that the message marks the end of the stream, and erases the secret key used to encrypt the previous sequence.\n\nThe `crypto_secretstream_xchacha20poly1305_push()` function encrypts the file `chunk` using the `state` and the `tag`, without any additional information (`null`).\n<br>\n\nthe XChaCha20 stream cipher Poly1305 MAC authentication are used for encryption.\n\n`stream.enqueue()` function adds the hat.sh signature(magic bytes), salt and header followed by the encrypted chunks.\n\n### File Decryption (stream)\n\n<div class=\"codeBox\">\n\n```javascript\nlet state = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n\nlet result = sodium.crypto_secretstream_xchacha20poly1305_pull(\n  state,\n  new Uint8Array(chunk)\n);\n\nif (result) {\n  let decryptedChunk = result.message;\n  stream.enqueue(decryptedChunk);\n\n  if (!last) {\n    // continue decryption\n  }\n}\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_pull()` function initializes a state given a secret `key` and a `header`. The key is derived from the password provided during the decryption, and the header sliced from the file. The key will not be required any more for subsequent operations.\n\n<br>\n\nThe `crypto_secretstream_xchacha20poly1305_pull()` function verifies that the `chunk` contains a valid ciphertext and authentication tag for the given `state`.\n\nThis function will stay in a loop, until a message with the `crypto_secretstream_xchacha20poly1305_TAG_FINAL` tag is found.\n\nIf the decryption key is incorrect the function returns an error.\n\nIf the ciphertext or the authentication tag appear to be invalid it returns an error.\n\n<br>\n\n### Random password generation\n\n<div class=\"codeBox\">\n\n```javascript\nlet password = sodium.to_base64(\n  sodium.randombytes_buf(16),\n  sodium.base64_variants.URLSAFE_NO_PADDING\n);\nreturn password;\n```\n\n</div>\n\nThe `randombytes_buf()` function fills 128 bits starting at buf with an unpredictable sequence of bytes.\n\nThe `to_base64()` function encodes buf as a Base64 string without padding.\n\n<br>\n\n### Keys generation and exchange\n\n<div class=\"codeBox\">\n\n```javascript\nconst keyPair = sodium.crypto_kx_keypair();\nlet keys = {\n  publicKey: sodium.to_base64(keyPair.publicKey),\n  privateKey: sodium.to_base64(keyPair.privateKey),\n};\nreturn keys;\n```\n</div>\n\nThe `crypto_kx_keypair()` function randomly generates a secret key and a corresponding public key. The public key is put into publicKey and the secret key into privateKey. both of 256 bits.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet key = sodium.crypto_kx_client_session_keys(\n  sodium.crypto_scalarmult_base(privateKey),\n  privateKey,\n  publicKey\n);\n```\n</div>\n\nUsing the key exchange API, two parties can securely compute a set of shared keys using their peer's public key and their own secret key.\n\nThe `crypto_kx_client_session_keys()` function computes a pair of 256 bits long shared keys using the recipient's public key, the sender's private key.\n\nThe `crypto_scalarmult_base()` function used to compute the sender's public key from their private key.\n\n<br>\n\n### XChaCha20-Poly1305\n\nXChaCha20 is a variant of ChaCha20 with an extended nonce, allowing random nonces to be safe.\n\nXChaCha20 doesn't require any lookup tables and avoids the possibility of timing attacks.\n\nInternally, XChaCha20 works like a block cipher used in counter mode. It uses the HChaCha20 hash function to derive a subkey and a subnonce from the original key and extended nonce, and a dedicated 64-bit block counter to avoid incrementing the nonce after each block.\n\n<br>\n\n### V2 vs V1\n\n- switching to xchacha20poly1305 for symmetric stream encryption and Argon2id for password-based key derivation. instead of AES-256-GCM and PBKDF2.\n- using the libsodium library for all cryptography instead of the WebCryptoApi.\n- in this version, the app doesn't read the whole file in memory. instead, it's sliced into 64MB chunks that are processed one by one.\n- since we are not using any server-side processing, the app registers a fake download URL (/file) that is going to be handled by the service-worker fetch api.\n- if all validations are passed, a new stream is initialized. then, file chunks are transferred from the main app to the\n  service-worker file via messages.\n- each chunk is encrypted/decrypted on it's own and added to the stream.\n- after each chunk is written on disk it is going to be immediately garbage collected by the browser, this leads to never having more than a few chunks in the memory at the same time.\n\n<br>\n\n[//]: # \"links\"\n[xchacha20-poly1305]: https://libsodium.gitbook.io/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction\n[argon2id]: https://github.com/p-h-c/phc-winner-argon2\n[x25519]: https://cr.yp.to/ecdh.html\n[opensource]: https://github.com/sh-dv/hat.sh\n[bitwarden]: https://bitwarden.com/\n[extending the salsa20 nonce paper]: https://cr.yp.to/snuffle/xsalsa-20081128.pdf\n[soon]: https://tools.ietf.org/html/draft-irtf-cfrg-xchacha\n[github]: https://github.com/sh-dv/hat.sh\n[veracrypt]: https://veracrypt.fr\n[cryptomator]: https://cryptomator.org\n[kryptor]: https://github.com/samuel-lucas6/Kryptor\n[gpg]: https://gnupg.org\n[docker hub]: https://hub.docker.com/r/shdv/hat.sh\n"},{"lang":"ja_JP","content":"# [Introduction](#introduction)\n\n---\n\nHat.sh is a free [opensource] web app that provides secure file encryption in the browser.\n\n<br>\n\n# [Features](#features)\n\n---\n\n### Security\n\n- [XChaCha20-Poly1305] - for symmetric encryption.\n- [Argon2id] - for password-based key derivation.\n- [X25519] - for key exchange.\n\nThe libsodium library is used for all cryptographic algorithms. [Technical details here](#technical-details).\n\n<br>\n\n### Privacy\n\n- The app runs locally in your browser.\n- No data is ever collected or sent to anyone.​\n\n<br>\n\n### Functionality\n\n- Secure encryption/decryption of files with passwords or keys.\n- Secure random password generation.\n- Asymmetric key pair generation.\n- Authenticated key exchange.\n- Password strength estimation.\n\n<br>\n\n# [Installation](#installation)\n\n---\nIt's easy to self host and deploy hat.sh, you can do that either with npm or docker\n\nIf you wish to self host the app please follow these instructions:\n\n<br>\n\n## With npm\n\nBefore installation make sure you are running [nodejs](https://nodejs.org/en/) and have [npm](https://www.npmjs.com/) installed\n\n<br >\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. install dependencies\n\n```bash\nnpm install\n```\n\n4. build app\n\n```bash\nnpm run build\n```\n\n5. start hat.sh\n\n```bash\nnpm run start\n```\n\nthe app should be running on port 3391.\n<br>\n\nif you wish to run the app in development enviroment run :\n\n<br>\n\n```bash\nnpm run dev\n```\n\n<br>\n\n## With docker\n\nYou can install the app with docker in multiple ways. You are free to choose which method you like.\n\n<br>\n\n- #### install from docker hub\n\n1. pull image from docker hub\n\n```bash\ndocker pull shdv/hat.sh:latest\n```\n\n2. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Build an image from source\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker\n\n```bash\ndocker build . -t shdv/hat.sh\n```\n\n4. run container\n\n```bash\ndocker run -d -p 3991:80 shdv/hat.sh\n```\n\n<br>\n\n- #### Using docker compose\n\n1. clone the github repository\n\n```bash\ngit clone https://github.com/sh-dv/hat.sh.git hat.sh\n```\n\n2. move to the folder\n\n```bash\ncd hat.sh\n```\n\n3. build image using docker compose\n\n```bash\ndocker compose build\n```\n\n4. run container\n\n```bash\ndocker compose up\n```\n\n<br>\n\nThe app should be running on port 3991.\n\nhat.sh is also available as a Docker image. You can find it on [Docker Hub].\n\n<br>\n\n\n# [Usage](#usage)\n\n---\n\n## File Encryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Enter a password or generate one.\n5. Download the encrypted file.\n\n> You should always use a strong password!\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Encryption panel.\n3. Drag & Drop or Select the files that you wish to encrypt.\n4. Choose public key method.\n5. Enter or load recipient's public key and your private key.\n   if you don't have public and private keys you can generate a key pair.\n6. Download the encrypted file.\n7. Share your public key with the recipient so he will be able to decrypt the file.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n## File Decryption\n\n- ### using a password\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter the encryption password.\n5. Download the decrypted file.\n\n- ### using public and private keys\n\n1. Open hat.sh.\n2. Navigate to the Decryption panel.\n3. Drag & Drop or Select the files that you wish to decrypt.\n4. Enter or load sender's public key and your private key.\n5. Download the decrypted file.\n\n<br>\n\n# [Limitations](#limitations)\n\n---\n\n### File Signature\n\nFiles encrypted with hat.sh are identifiable by looking at the file signature that is used by the app to verify the content of a file, Such signatures are also known as magic numbers or Magic Bytes. These Bytes are authenticated and cannot be changed.\n\n### Safari and Mobile Browsers\n\nSafari and Mobile browsers are limited to a single file with maximum size of 1GB due to some issues related to service-workers. In addition, this limitation also applies when the app fails to register the service-worker (e.g FireFox Private Browsing).\n\n<br>\n\n# [Best Practices](#best-practices)\n\n---\n\n### Choosing Passwords\n\nThe majority of individuals struggle to create and remember passwords, resulting in weak passwords and password reuse. Password-based encryption is substantially less safe as a result of these improper practices. That's why it is recommended to use the built in password generator and use a password manager like [Bitwarden], where you are able to store the safe password.\n\n\nIf you want to choose a password that you are able to memorize then you should type a passphrase made of 8 words or more.\n\n<br>\n\n### Using public key encryption instead of a password\n\nIf you are encrypting a file that you are going to share it with someone else then you probably should encrypt it with the recipient public key and your private key.\n\n<br>\n\n### Sharing Encrypted Files\n\nIf you plan on sending someone an encrypted file, it is recommended to use your private key and their public key to encrypt the file.\n\nThe file can be shared in any safe file sharing app.\n\n<br>\n\n### Sharing the public key\n\nPublic keys are allowed to be shared, they can be sent as `.public` file or as text.\n\n> Never share your private key to anyone! Only public keys should be exchanged.\n\n<br>\n\n### Storing the Public & Private keys\n\nMake sure to store your encryption keys in a safe place and make a backup to an external storage.\n\nStoring your private key in cloud storage is not recommended!\n\n<br>\n\n### Sharing Decryption Passwords\n\nSharing decryption password can be done using a safe end-to-end encrypted messaging app. It's recommended to use a _Disappearing Messages_ feature, and to delete the password after the recipient has decrypted the file.\n\n> Never choose the same password for different files.\n\n<br>\n\n# [FAQ](#faq)\n\n---\n\n### Does the app log or store any of my data?\n\nNo, hat.sh never stores any of your data. It only runs locally in your browser.\n\n<hr style=\"height: 1px\">\n\n### Is hat.sh free?\n\nYes, Hat.sh is free and always will be. However, please consider [donating](https://github.com/sh-dv/hat.sh#donations) to support the project.\n\n<hr style=\"height: 1px\">\n\n### Which file types are supported? Is there a file size limit?\n\nHat.sh accepts all file types. There's no file size limit, meaning files of any size can be encrypted.\n\nSafari browser and mobile/smartphones browsers are limited to 1GB.\n\n<hr style=\"height: 1px\">\n\n### I forgot my password, can I still decrypt my files?\n\nNo, we don't know your password. Always make sure to store your passwords in a password manager.\n\n<hr style=\"height: 1px\">\n\n### Why am I seeing a notice that says \"You have limited experience (single file, 1GB)\"?\n\nIt means that your browser doesn't support the server-worker fetch api. Hence, you are limited to small size files. see [Limitations](#limitations) for more info.\n\n<hr style=\"height: 1px\" id=\"why-need-private-key\">\n\n### Is it safe to share my public key?\n\nYes. Public keys are allowed to be shared, they can be sent as `.public` file or as text.\n\nBut make sure to never share your private key with anyone!\n\n<hr style=\"height: 1px\">\n\n### Why the app asks for my private key in the public key encryption mode?\n\nHat.sh uses authenticated encryption. The sender must provide their private key, a new shared key will be computed from both keys to encrypt the file. Recipient has to provide their private key when decrypting also. this way can verify that the encrypted file was not tampered with, and was sent from the real sender.\n\n<hr style=\"height: 1px\">\n\n### I have lost my private key, is it possible to recover it?\n\nNope. lost private keys cannot be recovered.\n\nAlso, if you feel that your private key has been compromised (e.g accidentally shared / computer hacked) then you must decrypt all files that were encrypted with that key, generate a new keypair and re-encrypt the files.\n\n<hr style=\"height: 1px\">\n\n### How do I generate a keypair (Public & Private)?\n\nYou can generate keys by visit the [key generate page](https://hat.sh/generate-keys), make sure to [store the keys safely](#best-practices).\n\n<hr style=\"height: 1px\">\n\n### Does the app measure password strength?\n\nWe use [zxcvbn](https://github.com/dropbox/zxcvbn) JS implementation to check the entropy of the password input, this entropy will be converted to score that will be displayed on screen.\n\n<hr style=\"height: 1px\">\n\n### Does the app connect to the internet?\n\nOnce you visit the site and the page loads, it runs only offline.\n\n<hr style=\"height: 1px\">\n\n### How can I contribute?\n\nHat.sh is an open-source application. You can help make it better by making commits on GitHub. The project is maintained in my free time. [Donations](https://github.com/sh-dv/hat.sh#donations) of any size are appreciated.\n\n<hr style=\"height: 1px\">\n\n### How do I report bugs?\n\nPlease report bugs via [Github] by opening an issue labeled with \"bug\".\n\n<hr style=\"height: 1px\">\n\n### How do I report a security vulnerability?\n\nIf you identify a valid security issue, please write an email to hatsh-security@pm.me\n\nThere is no bounty available at the moment, but your github account will be credited in the acknowledgements section in the app documentation.\n\n<hr style=\"height: 1px\">\n\n### Why should I use hat.sh?\n\n1. The app uses fast modern secure cryptographic algorithms.\n2. It's super fast and easy to use.\n3. It runs in the browser, no need to setup or install anything.\n4. It's free opensource software and can be easily self hosted.\n\n<hr style=\"height: 1px\">\n\n### When should I not use hat.sh?\n\n1. If you want to encrypt a disk (e.g [VeraCrypt]).\n2. If you want to frequently access encrypted files (e.g [Cryptomator]).\n3. If you want to encrypt and sign files in the same tool. (e.g [Kryptor]).\n4. If you prefer a command line tool (e.g [Kryptor]).\n5. If you want something that adheres to industry standards, use [GPG].\n\n<br>\n\n# [Technical Details](#technical-details)\n\n---\n\n### Password hashing and Key derivation\n\nPassword hashing functions derive a secret key of any size from a password and a salt.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet salt = sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);\nlet key = sodium.crypto_pwhash(\n  sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES,\n  password,\n  salt,\n  sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,\n  sodium.crypto_pwhash_ALG_ARGON2ID13\n);\n```\n\n</div>\n\nThe `crypto_pwhash()` function derives an 256 bits long key from a password and a salt salt whose fixed length is 128 bits, which should be unpredictable.\n\n`randombytes_buf()` is the easiest way to fill the 128 bits of the salt.\n\n<br>\n\n`OPSLIMIT` represents a maximum amount of computations to perform.\n\n`MEMLIMIT` is the maximum amount of RAM that the function will use, in bytes.\n\n<br>\n\n`crypto_pwhash_OPSLIMIT_INTERACTIVE` and `crypto_pwhash_MEMLIMIT_INTERACTIVE` provide base line for these two parameters. This currently requires 64 MiB of dedicated RAM. which is suitable for in-browser operations.\n<br>\n`crypto_pwhash_ALG_ARGON2ID13` using the Argon2id algorithm version 1.3.\n\n<br>\n\n### File Encryption (stream)\n\nIn order to use the app to encrypt a file, the user has to provide a valid file and a password. this password gets hashed and a secure key is derived from it with Argon2id to encrypt the file.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet res = sodium.crypto_secretstream_xchacha20poly1305_init_push(key);\nheader = res.header;\nstate = res.state;\n\nlet tag = last\n  ? sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL\n  : sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE;\n\nlet encryptedChunk = sodium.crypto_secretstream_xchacha20poly1305_push(\n  state,\n  new Uint8Array(chunk),\n  null,\n  tag\n);\n\nstream.enqueue(signature, salt, header, encryptedChunk);\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_push` function creates an encrypted stream where it initializes a `state` using the key and an internal, automatically generated initialization vector. It then stores the stream header into `header` that has a size of 192 bits.\n\nThis is the first function to call in order to create an encrypted stream. The key will not be required any more for subsequent operations.\n\n<br>\n\nAn encrypted stream starts with a short header, whose size is 192 bits. That header must be sent/stored before the sequence of encrypted messages, as it is required to decrypt the stream. The header content doesn't have to be secret because decryption with a different header would fail.\n\nA tag is attached to each message accoring to the value of `last`, which indicates if that is the last chunk of the file or not. That tag can be any of:\n\n1. `crypto_secretstream_xchacha20poly1305_TAG_MESSAGE`: This doesn't add any information about the nature of the message.\n2. `crypto_secretstream_xchacha20poly1305_TAG_FINAL`: This indicates that the message marks the end of the stream, and erases the secret key used to encrypt the previous sequence.\n\nThe `crypto_secretstream_xchacha20poly1305_push()` function encrypts the file `chunk` using the `state` and the `tag`, without any additional information (`null`).\n<br>\n\nthe XChaCha20 stream cipher Poly1305 MAC authentication are used for encryption.\n\n`stream.enqueue()` function adds the hat.sh signature(magic bytes), salt and header followed by the encrypted chunks.\n\n### File Decryption (stream)\n\n<div class=\"codeBox\">\n\n```javascript\nlet state = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n\nlet result = sodium.crypto_secretstream_xchacha20poly1305_pull(\n  state,\n  new Uint8Array(chunk)\n);\n\nif (result) {\n  let decryptedChunk = result.message;\n  stream.enqueue(decryptedChunk);\n\n  if (!last) {\n    // continue decryption\n  }\n}\n```\n\n</div>\n\nThe `crypto_secretstream_xchacha20poly1305_init_pull()` function initializes a state given a secret `key` and a `header`. The key is derived from the password provided during the decryption, and the header sliced from the file. The key will not be required any more for subsequent operations.\n\n<br>\n\nThe `crypto_secretstream_xchacha20poly1305_pull()` function verifies that the `chunk` contains a valid ciphertext and authentication tag for the given `state`.\n\nThis function will stay in a loop, until a message with the `crypto_secretstream_xchacha20poly1305_TAG_FINAL` tag is found.\n\nIf the decryption key is incorrect the function returns an error.\n\nIf the ciphertext or the authentication tag appear to be invalid it returns an error.\n\n<br>\n\n### Random password generation\n\n<div class=\"codeBox\">\n\n```javascript\nlet password = sodium.to_base64(\n  sodium.randombytes_buf(16),\n  sodium.base64_variants.URLSAFE_NO_PADDING\n);\nreturn password;\n```\n\n</div>\n\nThe `randombytes_buf()` function fills 128 bits starting at buf with an unpredictable sequence of bytes.\n\nThe `to_base64()` function encodes buf as a Base64 string without padding.\n\n<br>\n\n### Keys generation and exchange\n\n<div class=\"codeBox\">\n\n```javascript\nconst keyPair = sodium.crypto_kx_keypair();\nlet keys = {\n  publicKey: sodium.to_base64(keyPair.publicKey),\n  privateKey: sodium.to_base64(keyPair.privateKey),\n};\nreturn keys;\n```\n</div>\n\nThe `crypto_kx_keypair()` function randomly generates a secret key and a corresponding public key. The public key is put into publicKey and the secret key into privateKey. both of 256 bits.\n\n<br>\n\n<div class=\"codeBox\">\n\n```javascript\nlet key = sodium.crypto_kx_client_session_keys(\n  sodium.crypto_scalarmult_base(privateKey),\n  privateKey,\n  publicKey\n);\n```\n</div>\n\nUsing the key exchange API, two parties can securely compute a set of shared keys using their peer's public key and their own secret key.\n\nThe `crypto_kx_client_session_keys()` function computes a pair of 256 bits long shared keys using the recipient's public key, the sender's private key.\n\nThe `crypto_scalarmult_base()` function used to compute the sender's public key from their private key.\n\n<br>\n\n### XChaCha20-Poly1305\n\nXChaCha20 is a variant of ChaCha20 with an extended nonce, allowing random nonces to be safe.\n\nXChaCha20 doesn't require any lookup tables and avoids the possibility of timing attacks.\n\nInternally, XChaCha20 works like a block cipher used in counter mode. It uses the HChaCha20 hash function to derive a subkey and a subnonce from the original key and extended nonce, and a dedicated 64-bit block counter to avoid incrementing the nonce after each block.\n\n<br>\n\n### V2 vs V1\n\n- switching to xchacha20poly1305 for symmetric stream encryption and Argon2id for password-based key derivation. instead of AES-256-GCM and PBKDF2.\n- using the libsodium library for all cryptography instead of the WebCryptoApi.\n- in this version, the app doesn't read the whole file in memory. instead, it's sliced into 64MB chunks that are processed one by one.\n- since we are not using any server-side processing, the app registers a fake download URL (/file) that is going to be handled by the service-worker fetch api.\n- if all validations are passed, a new stream is initialized. then, file chunks are transferred from the main app to the\n  service-worker file via messages.\n- each chunk is encrypted/decrypted on it's own and added to the stream.\n- after each chunk is written on disk it is going to be immediately garbage collected by the browser, this leads to never having more than a few chunks in the memory at the same time.\n\n<br>\n\n[//]: # \"links\"\n[xchacha20-poly1305]: https://libsodium.gitbook.io/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction\n[argon2id]: https://github.com/p-h-c/phc-winner-argon2\n[x25519]: https://cr.yp.to/ecdh.html\n[opensource]: https://github.com/sh-dv/hat.sh\n[bitwarden]: https://bitwarden.com/\n[extending the salsa20 nonce paper]: https://cr.yp.to/snuffle/xsalsa-20081128.pdf\n[soon]: https://tools.ietf.org/html/draft-irtf-cfrg-xchacha\n[github]: https://github.com/sh-dv/hat.sh\n[veracrypt]: https://veracrypt.fr\n[cryptomator]: https://cryptomator.org\n[kryptor]: https://github.com/samuel-lucas6/Kryptor\n[gpg]: https://gnupg.org\n[docker hub]: https://hub.docker.com/r/shdv/hat.sh\n"}],"changelog":"# [CHANGELOG](#changelog)\n\n---\n## v2.3.6\n\n- Update packages\n- Czech translation (by [Franatrtur](https://github.com/Franatrtur)).\n- Turkish translation (by [darkao](https://github.com/darkao)).\n- Frank7sun translation (by [Frank7sun](https://github.com/Frank7sun)).\n\n## v2.3.5\n\n- Update packages\n- Slovak translation (by [t0mzSK](https://github.com/t0mzSK)).\n- Spanish translation (by [Xurdejl](https://github.com/Xurdejl)).\n\n## v2.3.4\n\n- Update packages\n- Russian translation (by [Ser-Bul](https://github.com/Ser-Bul)).\n- Italian translation (by [matteotardito](https://github.com/matteotardito)).\n\n## v2.3.3\n\n- Added page loading indicator.\n- Multiple UI elements redesign.\n- German translation (by [stophecom](https://github.com/stophecom)).\n- Fix file name encoding bug.\n- Update packages.\n- Code review, cleanup and bug fixes.\n\n## v2.3.2\n\n- Critical bug fix that lead to file decryption errors, and file encryption in certain cases. [Release info.](https://github.com/sh-dv/hat.sh/releases/tag/v2.3.2)\n\n## v2.3.1\n\n- Update packages\n- Code review, cleanup and bug fixes.\n\n## v2.3.0\n\n- Improve password strength checking.\n- Add password crack time estimation.\n- Automated translation according to browser locale.\n- Chinese translation (by [qaqland](https://github.com/qaqland)).\n- UI/UX tweaks.\n- Optimize docker containers.\n- Code review, cleanup and bug fixes.\n\n## v2.2.2\n\n- Sending the file name to SW instead of appending them to the URL.\n- French translation (by [bbouille](https://github.com/bbouille)).\n- Officially accepting Monero (xmr) for donations.\n- show English documentations as default if current locale documentations are not available.\n- Code review, cleanup and bug fixes.\n\n## v2.2.1\n\n- Create special page for key pair generation (accessible at /generate-keys)\n- Alert users when duplicate tabs are opened.\n- Disable back button while testing password/keys.\n- Minor bug fixes.\n\n## v2.2.0\n\n- Multiple files encryption/decryption.\n- Adding Dark Mode and tweaking styles.\n- Implementing custom localization.\n- In an effort to encourage the use of secure passwords, The minimum number of characters in the password input has been set to 12 characters.\n- Adding the ability to generate a QR code for the public key when generating a keypair.\n- New file picker design, display of total files counts and size. \n- Visiting different tabs through custom links (e.g ?tab=decryption).\n- Code review, cleanup and bug fixes.\n\n## v2.1.0\n\n- Fixed navigation bug that lead sometimes to duplicate functions which caused increased encrypted file size. (CRITICAL)\n- Documentation enhancement.\n- Bug fixes and code review.\n\n## v2.0.9\n\n- End to End testing with Cypress.\n- OS-level virtualization with Docker.\n- Show notification when copy to clipbaord.\n- Documentation enhancement.\n- Bug fixes and code review.\n\n## v2.0.8\n\n- Adding asymmetric key cryptography.\n- Adding a key pair generator.\n- Create shareable links that contain sender's public key.\n- Possibility to choose encryption methods.\n- Hide encryption passwords by default\n- Removal of idle timer.\n- File validation checks are now performed before passwords entry.\n- Documentation enhancement.\n- Bug fixes and code review.\n\n## v2.0.7\n\n- stable release of v2.\n- code review and minor bug fixes.\n\n## V2.0.6\n\n- Fix file name bug in decryption download.\n- Implementing the password strength checker using zxcvbn.\n- Adding a password generate button inside the password field in the encryption panel.\n- Adding a password visibility button (on/off) inside the password field in the decryption panel.\n- About page redesign (documentation).\n- Idle timer fixes.\n- Detect if the file was decrypted using an old version of hat.sh (v1).\n- Safely encode file names passed to SW.\n- Update node.js to the newest version.\n- Adding the changelog file to github.\n\n## V2.0.5\n\n- Fix critical bug with useEffect that leads to increased file output size.\n- Programming the markdown file parser for the hat.sh documentation.\n- Creating the About page.\n- Implementing an idle timer where user gets notified when they are inactive with app, where they are asked to reload the page.\n- Panel redesign.\n- Redesigning the Browse Button.\n- Adding an emoji on the homepage.\n- Removal of extra code comments.\n\n## V2.0.4\n- Code review.\n- Removal of unwanted lines of code.\n- Comments cleanup.\n\n## V2.0.3\n\n- Bug fixes.\n- Changing the whole UI design.\n- Improved File Validation.\n- Improved Password Validation.\n- Implementing a Stepper like design where the user has to go through steps to finish the encryption/decryption.\n- Safari and Mobile users are now limited to 1GB file.\n\n## V2.0.2\n- A lot of bug fixes and code cleaning.\n- Adding support to Safari and Mobile browsers.\n\n## V2.0.1\n- bug fixes.\n- Switching to React (next) instead of vanilla javascript.\n\n## V2.0.0\n\n- The birth of hat.sh v2 beta where it introduced in-browser memory efficient large file chunked encryption using streams with libsodium.js and switching algorithms to xchacha20poly1305 and argon2id."},"__N_SSG":true}